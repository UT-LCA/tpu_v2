--- vector_all.v	2021-12-15 09:26:29.916860500 -0600
+++ vpu_fin.v	2021-12-15 10:08:07.558376300 -0600
@@ -1,5 +1,5 @@
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vpu.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vpu.v
 //////////////////////////////////////////////////////////////////////
 /******************************************************************************
   Vector Control Pipeline
@@ -18,14 +18,15 @@
 //// Starting contents of included file: options.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/top/options.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/top/options.v
 //////////////////////////////////////////////////////////////////////
 `ifndef _OPTIONS_V_
 `define _OPTIONS_V_ 1
 
 `define NO_PLI 1
 //`define TEST_BENCH 1
-`define USE_INHOUSE_LOGIC
+//`define USE_INHOUSE_LOGIC
+//`define SIMULATION_MEMORY
 // Replaces altera blocks with local logic files
 
 /************************** ABBREVIEATED NAMES *****************************/
@@ -124,7 +125,7 @@
 //// Starting contents of included file: vregfile_base.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vregfile_base.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vregfile_base.v
 //////////////////////////////////////////////////////////////////////
 /****************************************************************************
           Base Register File
@@ -177,6 +178,8 @@
             reg_file1.DWIDTH=WIDTH;
 
 `else
+ //giving error in vtr even with yosys flow
+  /*
 	altsyncram	reg_file1(
 				.wren_a (c_we),
 				.clock0 (clk),
@@ -222,7 +225,9 @@
 		reg_file1.read_during_write_mode_mixed_ports = "OLD_DATA",
 		reg_file1.ram_block_type = "AUTO",
 		reg_file1.intended_device_family = "Stratix";
+ */
 `endif
+ 
 endmodule
 
 //////////////////////////////////////////////////////////////////////
@@ -232,7 +237,7 @@
 //// Starting contents of included file: vregfile_control.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vregfile_control.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vregfile_control.v
 //////////////////////////////////////////////////////////////////////
 /****************************************************************************
           Control Register File
@@ -436,6 +441,7 @@
 
 endmodule
 
+
 //////////////////////////////////////////////////////////////////////
 //// Finish contents of included file: vregfile_control.v
 //////////////////////////////////////////////////////////////////////
@@ -443,7 +449,7 @@
 //// Starting contents of included file: vregfile_flag.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vregfile_flag.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vregfile_flag.v
 //////////////////////////////////////////////////////////////////////
 /****************************************************************************
           Register File
@@ -523,7 +529,7 @@
             reg_file2.DWIDTH=WIDTH;
 
 `else
-
+    /*
     altsyncram	reg_file1(
           .clock0 (clk),
           .wren_a (c_we[k]),
@@ -617,7 +623,9 @@
       reg_file2.read_during_write_mode_mixed_ports = "OLD_DATA",
       reg_file2.ram_block_type = "AUTO",
       reg_file2.intended_device_family = "Stratix";
+  */
   `endif
+  
   end
   endgenerate
 
@@ -630,7 +638,7 @@
 //// Starting contents of included file: vregfile_inc.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vregfile_inc.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vregfile_inc.v
 //////////////////////////////////////////////////////////////////////
 /****************************************************************************
           inc Register File
@@ -685,6 +693,7 @@
             reg_file1.DWIDTH=WIDTH;
 
 `else
+ /*
 	altsyncram	reg_file1(
 				.wren_a (c_we&(|c_reg)),
 				.clock0 (clk),
@@ -730,6 +739,7 @@
 		reg_file1.read_during_write_mode_mixed_ports = "OLD_DATA",
 		reg_file1.ram_block_type = "AUTO",
 		reg_file1.intended_device_family = "Stratix";
+  */
 `endif
 endmodule
 
@@ -740,7 +750,7 @@
 //// Starting contents of included file: vregfile_scalar.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vregfile_scalar.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vregfile_scalar.v
 //////////////////////////////////////////////////////////////////////
 /****************************************************************************
           Scalar Register File
@@ -794,7 +804,7 @@
             reg_file1.NUM_WORDS=NUMREGS,
             reg_file1.DWIDTH=WIDTH;
  `else
-
+  /*
 	altsyncram	reg_file1(
 				.wren_a (c_we&(|c_reg)),
 				.clock0 (clk),
@@ -840,6 +850,7 @@
 		reg_file1.read_during_write_mode_mixed_ports = "OLD_DATA",
 		reg_file1.ram_block_type = "AUTO",
 		reg_file1.intended_device_family = "Stratix";
+  */
  `endif
 endmodule
 
@@ -850,7 +861,7 @@
 //// Starting contents of included file: vregfile_stride.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vregfile_stride.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vregfile_stride.v
 //////////////////////////////////////////////////////////////////////
 /****************************************************************************
           Stride Register File
@@ -903,6 +914,7 @@
             reg_file1.NUM_WORDS=NUMREGS,
             reg_file1.DWIDTH=WIDTH;
  `else
+ /*
 	altsyncram	reg_file1(
 				.wren_a (c_we),
 				.clock0 (clk),
@@ -948,6 +960,7 @@
 		reg_file1.read_during_write_mode_mixed_ports = "OLD_DATA",
 		reg_file1.ram_block_type = "AUTO",
 		reg_file1.intended_device_family = "Stratix";
+  */
 `endif
 endmodule
 
@@ -958,7 +971,7 @@
 //// Starting contents of included file: vregfile_vector.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vregfile_vector.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vregfile_vector.v
 //////////////////////////////////////////////////////////////////////
 /****************************************************************************
           Register File
@@ -1035,6 +1048,7 @@
               reg_file2.NUM_WORDS=NUMREGSPERBANK,
               reg_file2.DWIDTH=WIDTH;
   `else
+  /*
     altsyncram	reg_file1(
           .clock0 (clk),
           .wren_a (c_we[k] & ((WIDTH>8) ? 1'b1 : c_byteen[k])),
@@ -1130,6 +1144,7 @@
       reg_file2.read_during_write_mode_mixed_ports = "OLD_DATA",
       reg_file2.ram_block_type = "AUTO",
       reg_file2.intended_device_family = "Stratix";
+    */
   `endif
   end
   endgenerate
@@ -1143,7 +1158,7 @@
 //// Starting contents of included file: vcomponents.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vcomponents.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vcomponents.v
 //////////////////////////////////////////////////////////////////////
 /****************************************************************************
           Pipeline register - for transmitting a signal down several stages
@@ -1257,7 +1272,7 @@
 //// Starting contents of included file: vlanes.v.temp
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/vtr/vlanes.v.temp
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/vtr/vlanes.v.temp
 //////////////////////////////////////////////////////////////////////
 
 /******************************************************************************
@@ -1276,7 +1291,7 @@
 //// Starting contents of included file: vdispatcher.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vdispatcher.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vdispatcher.v
 //////////////////////////////////////////////////////////////////////
 
 
@@ -1559,7 +1574,7 @@
 //// Starting contents of included file: vlane_alu.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vlane_alu.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vlane_alu.v
 //////////////////////////////////////////////////////////////////////
 /****************************************************************************
 
@@ -1593,27 +1608,27 @@
 mux1_sel[1:0] 0 0 0 0 x x x x  x x   1 1 1 1  1 1 1 1  2   3 -- Combine
 flag_sel[1:0] x x x x 0 1 2 3  2 3   x x x x  x x x x  x   x /
 
-ALUOP_ZERO    =11'bzz1zzzz0101
-ALUOP_ADD     =11'b00z10zzzz00
-ALUOP_ADDU    =11'b00z00zzzz00
-ALUOP_SUB     =11'b00z11zzzz00
-ALUOP_SUBU    =11'b00z01zzzz00
-ALUOP_CMP_EQ  =11'b00z11zzzz00
-ALUOP_CMP_NEQ =11'b00z11zzzz01
-ALUOP_CMP_LT  =11'b00z11zzzz10
-ALUOP_CMP_LE  =11'b00z11zzzz11
-ALUOP_CMP_LT_U=11'b00z01zzzz10
-ALUOP_CMP_LE_U=11'b00z01zzzz11
-ALUOP_AND     =11'bzz0zz000101
-ALUOP_OR      =11'bzz0zz000001
-ALUOP_XOR     =11'bzz0zz001001
-ALUOP_NOR     =11'bzz0zz001101
+ALUOP_ZERO    =11'b00100000101
+ALUOP_ADD     =11'b00010000000
+ALUOP_ADDU    =11'b00000000000
+ALUOP_SUB     =11'b00011000000
+ALUOP_SUBU    =11'b00001000000
+ALUOP_CMP_EQ  =11'b00011000000
+ALUOP_CMP_NEQ =11'b00011000001
+ALUOP_CMP_LT  =11'b00011000010
+ALUOP_CMP_LE  =11'b00011000011
+ALUOP_CMP_LT_U=11'b00001000010
+ALUOP_CMP_LE_U=11'b00001000011
+ALUOP_AND     =11'b00000000101
+ALUOP_OR      =11'b00000000001
+ALUOP_XOR     =11'b00000001001
+ALUOP_NOR     =11'b00000001101
 ALUOP_MIN     =11'b00111010001
 ALUOP_MIN_U   =11'b00101010001
 ALUOP_MAX     =11'b00111100001
 ALUOP_MAX_U   =11'b00101100001
 ALUOP_ABS     =11'b11111000010
-ALUOP_MERGE   =11'b101z0000011
+ALUOP_MERGE   =11'b10100000011
 
 ****************************************************************************/
 
@@ -1621,7 +1636,7 @@
 //// Starting contents of included file: vlane_saturate.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vlane_saturate.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vlane_saturate.v
 //////////////////////////////////////////////////////////////////////
 /****************************************************************************
           Saturate unit
@@ -1881,6 +1896,7 @@
       local_adder_inst.PIPELINE = 0,
       local_adder_inst.REPRESENTATION = "SIGNED";
   `else
+  /*commenting due to error in yosys 
   lpm_add_sub adder_inst(
       .dataa({{2{ctrl_signed&adder_opA[WIDTH-1]}},adder_opA}),
       .datab({{2{ctrl_signed&adder_opB[WIDTH-1]}},adder_opB}),
@@ -1895,6 +1911,7 @@
       adder_inst.lpm_width=WIDTH+2,
       adder_inst.lpm_pipeline=0,
       adder_inst.lpm_representation="SIGNED";
+  */
   `endif
 
   assign lt=adder_result[WIDTH];
@@ -1978,13 +1995,13 @@
 //// Starting contents of included file: vmul_unit.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vmul_unit.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vmul_unit.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
 //// Starting contents of included file: vlane_mulshift.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vlane_mulshift.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vlane_mulshift.v
 //////////////////////////////////////////////////////////////////////
 
 /****************************************************************************
@@ -2075,6 +2092,7 @@
  local_mult_component.LPM_WIDTHP = 2*WIDTH + 2,
  local_mult_component.LPM_REPRESENTATION = "SIGNED";
 `else 
+/* 
 lpm_mult  lpm_mult_component (
   .dataa ({is_signed&opA_mux_out[WIDTH-1],opA_mux_out}),
   .datab (opB_mux_out),
@@ -2092,6 +2110,7 @@
   lpm_mult_component.lpm_type = "LPM_MULT",
   lpm_mult_component.lpm_representation = "SIGNED",
   lpm_mult_component.lpm_hint = "MAXIMIZE_SPEED=6";
+  */
 `endif
 // if A is positive/negative make it maximum/minimum positive/negative
 wire [WIDTH-1:0] signedsaturate=
@@ -2150,7 +2169,7 @@
 //// Starting contents of included file: vlane_barrelshifter.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vlane_barrelshifter.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vlane_barrelshifter.v
 //////////////////////////////////////////////////////////////////////
 /****************************************************************************
           Shifter unit
@@ -2203,6 +2222,7 @@
     local_shifter_inst1.LPM_WIDTHDIST = LOG2WIDTH,
     local_shifter_inst1.LPM_SHIFTTYPE="ARITHMETIC";
 `else
+/*
 lpm_clshift shifter_inst1(
     .data({sign_ext&opB[WIDTH-1],opB}),
     .distance(sa&(32'hffffffff<<((REGISTERBREAK>0) ? REGISTERBREAK : 0))),
@@ -2212,19 +2232,20 @@
     shifter_inst1.lpm_width = WIDTH+1,
     shifter_inst1.lpm_widthdist = LOG2WIDTH,
     shifter_inst1.lpm_shifttype="ARITHMETIC";
+  */
 `endif
 
-register partial_reg
+register_sync partial_reg
   ({dum,partial_result},clk,resetn,1'b1,{dum_,partial_result_});
     defparam partial_reg.WIDTH=WIDTH+1;
 
 wire [5-1:0] sa_2;
 wire shift_direction_2;
 
-register secondstage (sa, clk,resetn,1'b1,sa_2); 
+register_sync secondstage (sa, clk,resetn,1'b1,sa_2); 
   defparam secondstage.WIDTH=5;
 
-register secondstagedir (shift_direction, clk,resetn,1'b1,shift_direction_2); 
+register_sync secondstagedir (shift_direction, clk,resetn,1'b1,shift_direction_2); 
   defparam secondstagedir.WIDTH=1;
 
 `ifdef USE_INHOUSE_LOGIC
@@ -2239,6 +2260,7 @@
     local_shifter_inst2.LPM_WIDTHDIST = (REGISTERBREAK>0) ? REGISTERBREAK : 1,
     local_shifter_inst2.LPM_SHIFTTYPE ="ARITHMETIC";
 `else
+/*
 lpm_clshift shifter_inst2(
     .data({dum_,partial_result_}),
     .distance(sa_2[((REGISTERBREAK>0) ? REGISTERBREAK-1 : 0):0]),
@@ -2248,6 +2270,7 @@
     shifter_inst2.lpm_width = WIDTH+1,
     shifter_inst2.lpm_widthdist = (REGISTERBREAK>0) ? REGISTERBREAK : 1,
     shifter_inst2.lpm_shifttype="ARITHMETIC";
+    */
 `endif
 
 
@@ -2523,7 +2546,7 @@
 //// Starting contents of included file: vmem_unit.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vmem_unit.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vmem_unit.v
 //////////////////////////////////////////////////////////////////////
 // THIS UNIT SHOULD BE REDESIGNED!!!!!
 // It started off simple with low performance and after adding a bunch of hacks
@@ -2579,7 +2602,7 @@
 //// Starting contents of included file: velmshifter_serial.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/velmshifter_serial.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/velmshifter_serial.v
 //////////////////////////////////////////////////////////////////////
 /************************
  * An Inter-lane shift register
@@ -2855,7 +2878,7 @@
 //// Starting contents of included file: vmem_crossbar.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vmem_crossbar.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vmem_crossbar.v
 //////////////////////////////////////////////////////////////////////
 /************************
  *
@@ -3750,7 +3773,7 @@
 //// Starting contents of included file: vlane_flagalu.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/vlane_flagalu.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vlane_flagalu.v
 //////////////////////////////////////////////////////////////////////
 /******************************************************************************
 
@@ -3817,7 +3840,7 @@
 //// Starting contents of included file: matmul_unit.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/top/matmul_unit.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/top/matmul_unit.v
 //////////////////////////////////////////////////////////////////////
 
 `define DWIDTH 16
@@ -3854,7 +3877,7 @@
 //// Starting contents of included file: matmul_8x8.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/top/matmul_8x8.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/top/matmul_8x8.v
 //////////////////////////////////////////////////////////////////////
 
 
@@ -5868,46 +5891,44 @@
 //// Starting contents of included file: visa.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/visa.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/visa.v
 //////////////////////////////////////////////////////////////////////
-parameter COP2_VADD           = 'b10z0000000;
-parameter COP2_VADD_U         = 'b10z0000001;
-parameter COP2_VSUB           = 'b10zz000010;
-parameter COP2_VSUB_U         = 'b10zz000011;
-parameter COP2_VMULHI         = 'b10z0000100;
-parameter COP2_VMULHI_U       = 'b10z0000101;
-parameter COP2_VDIV           = 'b10zz000110; //Using as matmul
+parameter COP2_VADD           = 'b1000000000;
+parameter COP2_VADD_U         = 'b1000000001;
+parameter COP2_VSUB           = 'b1000000010;
+parameter COP2_VSUB_U         = 'b1000000011;
+parameter COP2_VMULHI         = 'b1000000100;
+parameter COP2_VMULHI_U       = 'b1000000101;
+parameter COP2_VDIV           = 'b1000000110; //Using as matmul
 //parameter COP2_VBFADD         = 'b0100000001; //Using BF16 add
 //parameter COP2_VBFMULT        = 'b0100000010; //Using BF16 MULT
 //parameter COP2_VACT           = 'b0100000011; //Using ACT
 //parameter COP2_VTRP           = 'b0100000100; //Using ACT
-parameter COP2_VDIV_U         = 'b10zz000111;
-
-//parameter COP2_VMOD           = 'b10zz001000;
-parameter COP2_VBFADD           = 'b10zz001000;  // USING bfloat add Instr: vmod.vv vrdest, vrsrc1,vrsrc2
+parameter COP2_VDIV_U         = 'b1000000111;
 
-//parameter COP2_VMOD_U         = 'b10zz001001;
-parameter COP2_VBFMULT         = 'b10zz001001;  // Using bfloat mult Instr: vmod.u.vv vrdest, vrsrc1,vrsrc2
-parameter COP2_VMOD_U         = 'b10zz001001;
-parameter COP2_VCMP_EQ        = 'b10zz001010;
-parameter COP2_VCMP_NE        = 'b10zz001100;
-parameter COP2_VCMP_LT        = 'b10zz001110;
-parameter COP2_VCMP_U_LT      = 'b10zz001111;
-parameter COP2_VCMP_LE        = 'b10zz010000;
-parameter COP2_VCMP_U_LE      = 'b10zz010001;
-parameter COP2_VMIN           = 'b10z0010010;
-parameter COP2_VMIN_U         = 'b10z0010011;
-parameter COP2_VMAX           = 'b10z0010100;
-parameter COP2_VMAX_U         = 'b10z0010101;
-parameter COP2_VMULLO         = 'b10z0010110;
+//parameter COP2_VMOD           = 'b1000001000;
+parameter COP2_VBFADD           = 'b1000001000;  // USING bfloat add Instr: vmod.vv vrdest, vrsrc1,vrsrc2
+parameter COP2_VBFMULT         = 'b1000001001;  // Using bfloat mult Instr: vmod.u.vv vrdest, vrsrc1,vrsrc2
+parameter COP2_VMOD_U         = 'b1000001001;
+parameter COP2_VCMP_EQ        = 'b1000001010;
+parameter COP2_VCMP_NE        = 'b1000001100;
+parameter COP2_VCMP_LT        = 'b1000001110;
+parameter COP2_VCMP_U_LT      = 'b1000001111;
+parameter COP2_VCMP_LE        = 'b1000010000;
+parameter COP2_VCMP_U_LE      = 'b1000010001;
+parameter COP2_VMIN           = 'b1000010010;
+parameter COP2_VMIN_U         = 'b1000010011;
+parameter COP2_VMAX           = 'b1000010100;
+parameter COP2_VMAX_U         = 'b1000010101;
+parameter COP2_VMULLO         = 'b1000010110;
 parameter COP2_VABS           = 'b1000010111;
-parameter COP2_VAND           = 'b10z0011000;
-parameter COP2_VOR            = 'b10z0011001;
-parameter COP2_VXOR           = 'b10z0011010;
-parameter COP2_VNOR           = 'b10z0011011;
-parameter COP2_VSLL           = 'b10zz011100;
-parameter COP2_VSRL           = 'b10zz011101;
-parameter COP2_VSRA           = 'b10zz011110;
+parameter COP2_VAND           = 'b1000011000;
+parameter COP2_VOR            = 'b1000011001;
+parameter COP2_VXOR           = 'b1000011010;
+parameter COP2_VNOR           = 'b1000011011;
+parameter COP2_VSLL           = 'b1000011100;
+parameter COP2_VSRL           = 'b1000011101;
+parameter COP2_VSRA           = 'b1000011110;
 parameter COP2_VSAT_B         = 'b1000011111;
 parameter COP2_VSAT_H         = 'b1001011111;
 //parameter COP2_VSAT_W         = 'b1010011111;
@@ -5921,26 +5942,26 @@
 parameter COP2_VSAT_U_H       = 'b1001100001;
 //parameter COP2_VSAT_U_W       = 'b1010100001;
 parameter COP2_VTRP       = 'b1010100001;   // Using transpose instruction: vsat.u.w vrdest, vrsrc 
-parameter COP2_VSADD          = 'b10z0100010;
-parameter COP2_VSADD_U        = 'b10z0100011;
-parameter COP2_VSSUB          = 'b10zz100100;
-parameter COP2_VSSUB_U        = 'b10zz100101;
+parameter COP2_VSADD          = 'b1000100010;
+parameter COP2_VSADD_U        = 'b1000100011;
+parameter COP2_VSSUB          = 'b1000100100;
+parameter COP2_VSSUB_U        = 'b1000100101;
 parameter COP2_VSRR           = 'b1000100110;
 parameter COP2_VSRR_U         = 'b1000100111;
 parameter COP2_VSLS           = 'b1000101000;
 parameter COP2_VSLS_U         = 'b1000101001;
-parameter COP2_VXUMUL         = 'b10z0101010;
-parameter COP2_VXUMUL_U       = 'b10z0101011;
-parameter COP2_VXLMUL         = 'b10z0101100;
-parameter COP2_VXLMUL_U       = 'b10z0101101;
-parameter COP2_VXUMADD        = 'b10z0101110;
-parameter COP2_VXUMADD_U      = 'b10z0101111;
-parameter COP2_VXUMSUB        = 'b10z0110000;
-parameter COP2_VXUMSUB_U      = 'b10z0110001;
-parameter COP2_VXLMADD        = 'b10z0110010;
-parameter COP2_VXLMADD_U      = 'b10z0110011;
-parameter COP2_VXLMSUB        = 'b10z0110100;
-parameter COP2_VXLMSUB_U      = 'b10z0110101;
+parameter COP2_VXUMUL         = 'b1000101010;
+parameter COP2_VXUMUL_U       = 'b1000101011;
+parameter COP2_VXLMUL         = 'b1000101100;
+parameter COP2_VXLMUL_U       = 'b1000101101;
+parameter COP2_VXUMADD        = 'b1000101110;
+parameter COP2_VXUMADD_U      = 'b1000101111;
+parameter COP2_VXUMSUB        = 'b1000110000;
+parameter COP2_VXUMSUB_U      = 'b1000110001;
+parameter COP2_VXLMADD        = 'b1000110010;
+parameter COP2_VXLMADD_U      = 'b1000110011;
+parameter COP2_VXLMSUB        = 'b1000110100;
+parameter COP2_VXLMSUB_U      = 'b1000110101;
 parameter COP2_VINS_VV        = 'b1100000000;
 parameter COP2_VINS_SV        = 'b1110000001;
 parameter COP2_VEXT_VV        = 'b1100000010;
@@ -5948,17 +5969,17 @@
 parameter COP2_VEXT_U_SV      = 'b1100000100;
 parameter COP2_VCOMPRESS      = 'b1100000101;
 parameter COP2_VEXPAND        = 'b1100000110;
-parameter COP2_VMERGE         = 'b11zz000111;
+parameter COP2_VMERGE         = 'b1100000111;
 parameter COP2_VFINS          = 'b1110001000;
 parameter COP2_VEXTHALF       = 'b1100001001;
 parameter COP2_VHALF          = 'b1100001010;
 parameter COP2_VHALFUP        = 'b1100001011;
 parameter COP2_VHALFDN        = 'b1100001100;
 parameter COP2_VSATVL         = 'b1100001101;
-parameter COP2_VFAND          = 'b11z0001110;
-parameter COP2_VFOR           = 'b11z0001111;
-parameter COP2_VFXOR          = 'b11z0010000;
-parameter COP2_VFNOR          = 'b11z0010001;
+parameter COP2_VFAND          = 'b1100001110;
+parameter COP2_VFOR           = 'b1100001111;
+parameter COP2_VFXOR          = 'b1100010000;
+parameter COP2_VFNOR          = 'b1100010001;
 parameter COP2_VFCLR          = 'b1100010010;
 parameter COP2_VFSET          = 'b1100010011;
 parameter COP2_VIOTA          = 'b1100010100;
@@ -6198,13 +6219,15 @@
 reg                [ NUMBANKS*NUMLANES-1 : 0 ]   vf_c_writedatain;
 reg                            [ NUMBANKS-1:0]   vf_c_we;
 
-wire [(((NUMFUS-1)-(0)+1)*((REGIDWIDTH-1)-(0)+1))-1 : 0] wb_dst;
+wire             [ REGIDWIDTH*NUMFUS-1 : 0 ]   wb_dst;
 wire                     [NUMFUS-1:0]   wb_dst_we;
 wire [(((NUMFUS-1)-(0)+1)*((NUMLANES-1)-(0)+1))-1 : 0] wb_dst_mask;
 
-wire [(((NUMFUS-1)-(0)+1)*((`MAX_STAGES-1)-(4)+1))-1 : 0] dst_we;
-wire [(((`MAX_STAGES-1)-(4)+1)*((REGIDWIDTH-1)-(0)+1))-1 : 0] dst[NUMFUS-1:0];
-wire [(((`MAX_STAGES-1)-(4)+1)*((NUMLANES-1)-(0)+1))-1 : 0] dst_mask[NUMFUS-1:0];
+//wire [(((NUMFUS-1)-(0)+1)*((`MAX_STAGES-1)-(4)+1))-1 : 0] dst_we;
+wire [(`MAX_STAGES-4)*NUMFUS-1:0] dst_we;
+wire [(`MAX_STAGES-4) * NUMFUS * REGIDWIDTH-1 : 0 ] dst;
+
+wire [(((`MAX_STAGES-1)-(4)+1)*((NUMLANES-1)-(0)+1)*NUMFUS)-1 : 0] dst_mask;
 wire             [ REGIDWIDTH-1 : 0 ]   dst_s2;
 reg [(((NUMBANKS-1)-(0)+1)*((REGIDWIDTH-1)-(0)+1))-1 : 0] _dst_s3;
 reg [(((NUMBANKS-1)-(0)+1)*((REGIDWIDTH-1)-(0)+1))-1 : 0] dst_s3;
@@ -6223,7 +6246,7 @@
 wire             [ REGIDWIDTH-1 : 0 ]   src2_s2;
 reg [(((NUMBANKS-1)-(0)+1)*((REGIDWIDTH-1)-(0)+1))-1 : 0] src1_s3;
 reg [(((NUMBANKS-1)-(0)+1)*((REGIDWIDTH-1)-(0)+1))-1 : 0] src2_s3;
-reg [(((NUMBANKS-1)-(0)+1)*((REGIDWIDTH-1)-(0)+1))-1 : 0] _src1_s3;
+reg [NUMBANKS*REGIDWIDTH-1:0] _src1_s3;
 reg [(((NUMBANKS-1)-(0)+1)*((REGIDWIDTH-1)-(0)+1))-1 : 0] _src2_s3;
 wire                                    src1scalar_s2;
 wire                                    src2scalar_s2;
@@ -6239,20 +6262,20 @@
 reg                     [LOG2MVL-1:0]   src_start_delayed;
 wire                    [LOG2MVL-1:0]   src_elm;
 wire                    [LOG2MVL-1:0]   src_limit;
-reg [(((NUMBANKS-1)-(0)+1)*((LOG2MVL-1)-(0)+1))-1 : 0] src_limit_s3;
+reg                     [LOG2MVL*NUMBANKS-1:0]   src_limit_s3;
 wire                    [LOG2MVL-1:0]   src_start;
 
 wire                    [VCWIDTH-1:0]   total_shamt;
 wire                    [LOG2MVL-1:0]   dst_start;
-
+             //output of various blocks
 reg [(((NUMFUS-1)-(0)+1)*((LANEWIDTH*NUMLANES-1)-(0)+1))-1 : 0] vr_src1;
 reg [(((NUMFUS-1)-(0)+1)*((LANEWIDTH*NUMLANES-1)-(0)+1))-1 : 0] vr_src2;
 wire         [ LANEWIDTH*NUMLANES-1 : 0 ]   matmul_out;
 wire         [ LANEWIDTH*NUMLANES-1 : 0 ]   bfadder_result_s5;
 wire         [ LANEWIDTH*NUMLANES-1 : 0 ]   bfmult_result_s5;
 wire         [ LANEWIDTH*NUMLANES-1 : 0 ]   act_result_s5;
-wire         [ LANEWIDTH*NUMLANES-1 : 0 ]   trp_out;
-wire         [ LANEWIDTH*NUMLANES-1 : 0 ]   permute_out;
+wire         [ LANEWIDTH*NUMLANES-1 : 0 ]   trp_out; //output of reduction unit
+wire         [ LANEWIDTH*NUMLANES-1 : 0 ]   permute_out; //output of permute block
 wire         [ LANEWIDTH*NUMLANES-1 : 0 ]   transpose_out;
 reg [(((NUMFUS-1)-(0)+1)*((NUMLANES-1)-(0)+1))-1 : 0] vf_src1;
 reg [(((NUMFUS-1)-(0)+1)*((NUMLANES-1)-(0)+1))-1 : 0] vf_src2;
@@ -6559,7 +6582,7 @@
 
 //tell vpu to hold vc,vbase,etc values
 assign is_stalled=~internal_pipe_advance | {stall_srcstart,2'b0};
-
+//debug signals
 assign has_memop=ctrl1_mem_en|ctrl2_mem_en|(|ctrl3_mem_en)|ctrl4_mem_en|ctrl5_mem_en;
 
 /******************************************************************************/
@@ -6568,22 +6591,24 @@
 
 /* Memunit is in stage 5 but we stall in stage 4 so we don't squash the
 * destination register contents*/
-
+//do we have to advance the pipeline stage (stall condition checking)
 assign pipe_advance=internal_pipe_advance & ~{5'b0,stall_in};
-
+//advance pipeline stage 0 only if next pipeline stage is advancing
 assign internal_pipe_advance[0]=internal_pipe_advance[1];
 assign internal_pipe_advance[1]=internal_pipe_advance[2];
-assign internal_pipe_advance[2]=internal_pipe_advance[3] && 
-                          ~stall_srcstart &&
-                          ~stall_dispatcher &&
+assign internal_pipe_advance[2]=internal_pipe_advance[3] &&  //checking for hazard conditions as well
+                          ~stall_srcstart &&                     
+                          ~stall_dispatcher && //if vl-length is set more than 8, dispatcher will stall since it has only 8 lanes
                           ~stall_hazsrc1 && ~stall_hazsrc2 && 
                           ~stall_hazfsrc1 && ~stall_hazfsrc2 && 
                           ~stall_mulcooldown; 
 assign internal_pipe_advance[3]=internal_pipe_advance[4];
 assign internal_pipe_advance[4]=internal_pipe_advance[5];
-assign internal_pipe_advance[5]=internal_pipe_advance[6] && ~stall_mulunit && ~stall_memunit && ~temp_stall_matmul;
+assign internal_pipe_advance[5]=internal_pipe_advance[6] && ~stall_mulunit && ~stall_memunit && ~temp_stall_matmul; 
+                                                                                                //matmul stall may or may not be reqd
 //assign internal_pipe_advance[6]=1'b1;
 
+//putting nop signals - previous pipeline stage stall
 assign pipe_squash[0]=pipe_advance[1]&~pipe_advance[0];
 assign pipe_squash[1]=pipe_advance[2]&~pipe_advance[1];
 assign pipe_squash[2]=pipe_advance[3]&~pipe_advance[2];
@@ -6592,6 +6617,8 @@
 assign pipe_squash[5]=pipe_advance[6]&~pipe_advance[5];
 assign pipe_squash[6]=1'b0;
 assign pipe_squash[13:7]= 'h0;
+
+//This is for the pipeline stages we added and we don't expect stalls here , hence set to 1
 assign internal_pipe_advance[13:6] = {(14-5){1'b1}};
 //assign pipe_squash[`MAX_STAGES:7]= 'h0;
 //assign internal_pipe_advance[`MAX_STAGES:6] = {(`MAX_STAGES-5){1'b1}};
@@ -6609,15 +6636,15 @@
 
   // Determine which instruction read from which ports
   always@*
-  begin
+  begin //This regfile has 2 read ports and 1 write port;hence 3 enables 
     ctrl1_vr_a_en=0;
     ctrl1_vr_b_en=0;
     ctrl1_vr_c_en=0;
-    ctrl1_vf_a_en=0;
+    ctrl1_vf_a_en=0; //don't really use vf - vector flags or vf_sel signals
     ctrl1_vf_b_en=0;
     ctrl1_vf_a_sel=0;
     ctrl1_usesvssel=0;
-    case(ir_op)
+    case(ir_op) //decode the registers based on the IR op (current instr)
     COP2_VADD:
         begin
           ctrl1_vf_a_en=1;
@@ -6734,14 +6761,6 @@
           ctrl1_vr_b_en=1;
           ctrl1_usesvssel=1;
         end
-    COP2_VBFMULT:
-        begin
-          bf_op = 0;
-          ctrl1_vf_a_en=1;
-          ctrl1_vr_a_en=~ir_op[BIT_VSSRC1];
-          ctrl1_vr_b_en=1;
-          ctrl1_usesvssel=1;
-        end
     COP2_VMIN:
         begin
           bf_op = 0;
@@ -7159,7 +7178,6 @@
       //COP2_VFLD:
       //COP2_VBFADD,
       //COP2_VLD_U_W,
-      //COP2_VBFMULT:
     COP2_VLD_B:
         begin
           ctrl1_vf_a_en=1;
@@ -7204,6 +7222,10 @@
         begin
           ctrl1_vf_a_en=1;
         end
+    //COP2_VBFMULT:
+    //    begin
+    //      ctrl1_vf_a_en=1;
+    //    end
       //COP2_VTRP,
       //COP2_VRED,
      // COP2_VACT:
@@ -7328,7 +7350,7 @@
     endcase
   end
 
-  // Decode enables 
+  // Decode enables ; some of the enable signals for the functional units
   always@*
   begin
     ctrl1_vr_d_we=0;
@@ -7870,9 +7892,7 @@
           ctrl1_vf_c_we=1;
         end
       //COP2_VFLD,
-      //COP2_VBFADD,
       //COP2_VLD_U_W,
-      //COP2_VBFMULT:
     COP2_VLD_B:
         begin
           ctrl1_vr_d_we=1;
@@ -7889,6 +7909,14 @@
           ctrl1_mem_en=1;
           ctrl1_ismasked=1;
         end
+    COP2_VBFADD:
+        begin
+          ctrl1_vr_d_we=1;
+          ctrl1_vrdest_sel=1;
+          ctrl1_memunit_en=1;
+          ctrl1_mem_en=1;
+          ctrl1_ismasked=1;
+        end
     COP2_VLD_L:
         begin
           ctrl1_vr_d_we=1;
@@ -7961,6 +7989,14 @@
           ctrl1_mem_en=1;
           ctrl1_ismasked=1;
         end
+    //COP2_VBFMULT:
+    //   begin
+    //     ctrl1_vr_d_we=1;
+    //     ctrl1_vrdest_sel=1;
+    //     ctrl1_memunit_en=1;
+    //     ctrl1_mem_en=1;
+    //     ctrl1_ismasked=1;
+    //   end
      // COP2_VTRP,
      // COP2_VACT:
     COP2_VLDX_B:
@@ -8128,8 +8164,8 @@
     ctrl1_flagalu_op=FLAGOP_CLR;
     ctrl1_permute_read = 1'b0;
   end
-  always@*
-  begin
+  always@* //enable signals for our functional units
+  begin    
     ctrl1_alu_op=ALUOP_ZERO^ALUOP_ZERO;
     ctrl1_satsum_op=SATSUMOP_NOP;
     ctrl1_satsize_op=SATSIZEOP_VSATUW;
@@ -8155,7 +8191,7 @@
       COP2_VMULHI_U:ctrl1_mulshift_op=MULOP_MULUHI;
       COP2_VDIV:    ctrl1_matmul_en=1'b1;  //Note: This is a hack. We're using VDIV opcode for matmul operation
       COP2_VBFADD:    ctrl1_bfadder_en = 1'b1;
-      COP2_VBFMULT:   ctrl1_bfmult_en = 1'b1;
+      //COP2_VBFMULT:   ctrl1_bfmult_en = 1'b1;
       COP2_VACT:      ctrl1_act_en = 1'b1;
       COP2_VTRP:      ctrl1_transpose_en = 1'b1;
       COP2_VRED:      ctrl1_trp_en = 1'b1;
@@ -8264,7 +8300,7 @@
       //COP2_VLDS_L:
       COP2_VLDS_U_B: ctrl1_memunit_op=MEMOP_LDSUB;
       COP2_VLDS_U_H: ctrl1_memunit_op=MEMOP_LDSUH;
-      //COP2_VBFMULT: ctrl1_memunit_op=MEMOP_LDSUW;
+      COP2_VBFMULT: ctrl1_memunit_op=MEMOP_LDSUW;
       COP2_VLDX_B: ctrl1_memunit_op=MEMOP_LDXB;
       COP2_VLDX_H: ctrl1_memunit_op=MEMOP_LDXH;
       //COP2_VTRP: ctrl1_memunit_op=MEMOP_LDXW;
@@ -8280,7 +8316,7 @@
       COP2_VSTS_B: ctrl1_memunit_op=MEMOP_STSB;
       COP2_VSTS_H: ctrl1_memunit_op=MEMOP_STSH;
       //COP2_VPER: ctrl1_memunit_op=MEMOP_STSW;
-    COP2_VPER_STR:
+      COP2_VPER_STR: //permute store instruction
         begin
            ctrl1_permute_read = 1'b1;
            ctrl1_permute_en = 1'b1;
@@ -8311,7 +8347,7 @@
   assign regid_pad=0;
 
   pipereg 
-    #(
+    #( //one pipeline stage with total number of registers
       2+
       2+
       1+
@@ -8327,7 +8363,7 @@
       }),
       .clk(clk),
       .resetn(resetn),
-      .en( pipe_advance[1] ),
+      .en( pipe_advance[1] ), //only enable register if pipe advance
       .squashn( 1'b1 ),
       .q({
         ctrl2_elmshamt_sel,
@@ -8459,7 +8495,7 @@
         ctrl1_flagalu_op,
         ctrl1_vf_wbsel,
         ctrl1_volatiledest,
-        trp_mode_s1
+        trp_mode_s1 //selects mode for trp unit (for reduction operation)
       }),
       .clk(clk),
       .resetn(resetn),
@@ -8512,7 +8548,7 @@
       src_start_delayed<=src_start;
 
   assign src_start= ( ctrl2_srcshamt_sel==3 ) ? vc[((2-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((2-2)*((VCWIDTH-1)-(0)+1))] :           // vcindex
-               ( ctrl2_srcshamt_sel==1 ) ? vl[((2-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-1) : ((2-2)*((VCWIDTH-1)-(0)+1))] :   // vl>>2
+               ( ctrl2_srcshamt_sel==1 ) ? vl[((2-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-1) : ((2-2)*((VCWIDTH-1)-(0)+1))] :   // vl>>2 ; vl is from the vector control code 
                ( ctrl2_srcshamt_sel==2 ) ? 1 << vc[((2-2)*((VCWIDTH-1)-(0)+1)+LOG2MVL-1-0) : ((2-2)*((VCWIDTH-1)-(0)+1))]://2^vcindex
                0;
 
@@ -8565,6 +8601,7 @@
     end
 
   wire [6:2] squash_vcpipe_NC;
+  //transfer control pipelines based on pipe_advance
   pipe #(VCWIDTH,4) vcpipe (
       .d( (!pipe_advance_s2_r) ? vc_in_saved : vc_in ),
       .clk(clk),
@@ -8573,7 +8610,7 @@
       .squash(squash_vcpipe_NC),
       .q( {vc[((6-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((6-2)*((VCWIDTH-1)-(0)+1))],vc[((5-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((5-2)*((VCWIDTH-1)-(0)+1))],vc[((4-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((4-2)*((VCWIDTH-1)-(0)+1))],vc[((3-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((3-2)*((VCWIDTH-1)-(0)+1))],vc[((2-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((2-2)*((VCWIDTH-1)-(0)+1))]} ));
 
-  wire [6:2] squash_vlpipe_NC;
+  wire [6:2] squash_vlpipe_NC; //transferring vl_Length
   pipe #(VCWIDTH,4) vlpipe (
       .d( (!pipe_advance_s2_r) ? vl_in_saved : vl_in ),
       .clk(clk),
@@ -8582,7 +8619,7 @@
       .squash(squash_vlpipe_NC),
       .q( {vl[((6-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((6-2)*((VCWIDTH-1)-(0)+1))],vl[((5-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((5-2)*((VCWIDTH-1)-(0)+1))],vl[((4-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((4-2)*((VCWIDTH-1)-(0)+1))],vl[((3-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((3-2)*((VCWIDTH-1)-(0)+1))],vl[((2-2)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((2-2)*((VCWIDTH-1)-(0)+1))]} ));
 
-  wire [6:2] squash_vbasepipe_NC;
+  wire [6:2] squash_vbasepipe_NC; //base address
   pipe #(VCWIDTH,4) vbasepipe (
       .d( (!pipe_advance_s2_r) ? vbase_in_saved : vbase_in ),
       .clk(clk),
@@ -8615,9 +8652,12 @@
 
 
   /*****************************    ISSUER    *****************************/
-
+  //dispatching to the execution units
   assign stall_dispatcher=
     //Structural hazard
+    //last_subvector- last cycle in vector operation (will be high in last cycle)
+    //have this for all the extra functional units that are added as well
+    //active low??
     (|(ctrl3_memunit_en&~last_subvector) && ctrl2_memunit_en) ||
     (|(ctrl3_mulshift_en&~last_subvector) && ctrl2_mulshift_en) ||
     (|(ctrl3_matmul_en&~last_subvector) && ctrl2_matmul_en) ||
@@ -8746,7 +8786,7 @@
       .rdelm_valuetoadd(NUMLANES),
       .wrelm_valuetoadd(NUMLANES),
       .count_valuetoadd(1),
-      .instr(dispatcher_instr),
+      .instr(dispatcher_instr), //will take all control unit signals from previous stage and will pack into this instr
       .first(first_subvector),
       .rdelm(rdelm),
       .wrelm(wrelm),
@@ -8756,32 +8796,36 @@
   
 
   /******************* Stall on RAW HAZARDS ************************/
-
+  //removed for loop for number of banks, bring it back again if needed
   always@*
     for (bd=0; bd<1+(NUMBANKS-1)*ALUPERBANK; bd=bd+1)
     begin
-      alu_dst[((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)*REGIDWIDTH-1)-(0)+1)) +: ( REGIDWIDTH)]=dst[FU_ALU+bd][4];
-      alu_dst_we[((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)-1)-(0)+1)+bd-bd) : ((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)-1)-(0)+1))]=dst_we[FU_ALU+bd][4];
-      falu_dst[((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)*REGIDWIDTH-1)-(0)+1)) +: ( REGIDWIDTH)]=dst[FU_FALU+bd][4];
-      falu_dst_we[((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)-1)-(0)+1)+bd-bd) : ((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)-1)-(0)+1))]=dst_we[FU_FALU+bd][4];
-    end
+      alu_dst[0*REGIDWIDTH +: REGIDWIDTH] = dst[(FU_ALU+bd)*(`MAX_STAGES-4)*(REGIDWIDTH)+: REGIDWIDTH];
+
+      alu_dst_we[0] = dst_we[(FU_ALU+bd)*(`MAX_STAGES-4)];
 
+      falu_dst[0*REGIDWIDTH +: REGIDWIDTH] = dst[(FU_ALU+bd)*(`MAX_STAGES-4)*(REGIDWIDTH)+: REGIDWIDTH];
+
+      falu_dst_we[0] = dst_we[(FU_FALU+bd)*(`MAX_STAGES-4)];
+    end
 
+  //TODO: hazard checker for the pipeline- need to update this for the other functional units 
+  //src1_s2 , src2_s2 (source 1, stage 1 & son on) 
   hazardchecker #(REGIDWIDTH,VELMIDWIDTH,4+(NUMBANKS-1)*ALUPERBANK,NUMBANKS) 
     src1hazchecker(
       .src( src1_s2 |(src_start_delayed[LOG2MVL-1:0]>>LOG2NUMLANES) ),
       .src_valid(ctrl2_vr_a_en),
       .dst({
         alu_dst[((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)*REGIDWIDTH-1)-(0)+1)+(1+(NUMBANKS-1)*ALUPERBANK)*REGIDWIDTH-1-0) : ((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)*REGIDWIDTH-1)-(0)+1))],
-        dst[FU_MUL][4],
-        dst[FU_MEM][4],
-        dst[FU_MATMUL][4]
+        dst[(`MAX_STAGES-4)*(FU_MUL*REGIDWIDTH)+ REGIDWIDTH-1:(`MAX_STAGES-4)*(FU_MUL*REGIDWIDTH) ],
+        dst[(`MAX_STAGES-4)*(FU_MEM*REGIDWIDTH)+ REGIDWIDTH-1 : (`MAX_STAGES-4)*(FU_MEM*REGIDWIDTH)],
+        dst[(`MAX_STAGES-4)*(FU_MATMUL*REGIDWIDTH)+REGIDWIDTH-1: (`MAX_STAGES-4)*(FU_MATMUL*REGIDWIDTH)]
         }),
       .dst_valid({
         alu_dst_we[((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)-1)-(0)+1)+(1+(NUMBANKS-1)*ALUPERBANK)-1-0) : ((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)-1)-(0)+1))],
-        dst_we[((FU_MUL-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_MUL-0)*((`MAX_STAGES-1)-(4)+1))],
-        dst_we[((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1))],
-        dst_we[((FU_MATMUL-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_MATMUL-0)*((`MAX_STAGES-1)-(4)+1))]
+        dst_we[(FU_MUL)*(`MAX_STAGES-4)],
+        dst_we[(FU_MEM)*(`MAX_STAGES-4)],
+        dst_we[(FU_MATMUL)*(`MAX_STAGES-4)]
         }),
       .dst_mode({{3+(NUMBANKS-1)*ALUPERBANK{1'b0}},ctrl4_volatiledest}),
       .lt_dst(t_dst_s3),
@@ -8795,15 +8839,15 @@
       .src_valid(ctrl2_vr_b_en),
       .dst({
         alu_dst[((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)*REGIDWIDTH-1)-(0)+1)+(1+(NUMBANKS-1)*ALUPERBANK)*REGIDWIDTH-1-0) : ((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)*REGIDWIDTH-1)-(0)+1))],
-        dst[FU_MUL][4],
-        dst[FU_MEM][4],
-        dst[FU_MATMUL][4]
+        dst[(`MAX_STAGES-4)*(FU_MUL*REGIDWIDTH)+REGIDWIDTH-1: (`MAX_STAGES-4)*(FU_MUL*REGIDWIDTH)],
+        dst[(`MAX_STAGES-4)*(FU_MEM*REGIDWIDTH)+REGIDWIDTH-1: (`MAX_STAGES-4)*(FU_MEM*REGIDWIDTH)],
+        dst[(`MAX_STAGES-4)*(FU_MATMUL*REGIDWIDTH)+REGIDWIDTH-1: (`MAX_STAGES-4)*(FU_MATMUL*REGIDWIDTH)]
         }),
       .dst_valid({
         alu_dst_we[((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)-1)-(0)+1)+(1+(NUMBANKS-1)*ALUPERBANK)-1-0) : ((4-4)*(((1+(NUMBANKS-1)*ALUPERBANK)-1)-(0)+1))],
-        dst_we[((FU_MUL-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_MUL-0)*((`MAX_STAGES-1)-(4)+1))],
-        dst_we[((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1))],
-        dst_we[((FU_MATMUL-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_MATMUL-0)*((`MAX_STAGES-1)-(4)+1))]
+        dst_we[(FU_MUL)*(`MAX_STAGES-4) ],
+        dst_we[(FU_MEM)*(`MAX_STAGES-4)],
+        dst_we[(FU_MATMUL)*(`MAX_STAGES-4)]
         }),
       .dst_mode({{3+(NUMBANKS-1)*ALUPERBANK{1'b0}},ctrl4_volatiledest}),
       .lt_dst(t_dst_s3),
@@ -8812,6 +8856,7 @@
       .haz(stall_hazsrc2));
 
   //Check flag hazards - flags always start at 0th element
+  //there are no instrutions like branches which use the flags
   hazardchecker #(REGIDWIDTH,VELMIDWIDTH,1+(NUMBANKS-1)*ALUPERBANK,NUMBANKS) 
     fsrc1hazchecker(
       // Check for mask flag and src1 flag depending on instruction
@@ -8843,7 +8888,7 @@
 /******************************************************************************/
 
   always@*
-    for (bi=0; bi<NUMBANKS; bi=bi+1)
+    for (bi=0; bi<NUMBANKS; bi=bi+1) //NUMBANKS is currently 1
     begin
       {
         src_limit_s3[((bi-0)*((LOG2MVL-1)-(0)+1)+LOG2MVL-1-0) : ((bi-0)*((LOG2MVL-1)-(0)+1))],
@@ -8894,7 +8939,8 @@
         D_instr_s3[((bi-0)*((7)-(0)+1)+7-0) : ((bi-0)*((7)-(0)+1))],
         trp_mode_s3[((bi-0)*((1)-(0)+1)+1-0) : ((bi-0)*((1)-(0)+1))]
       } = dispatcher_instr>>(bi*(`DISPATCHWIDTH));
-
+      //dispatcher instr will be split into many control signals for the next stage
+      //dispatcher might give same control signals for multiple cycles
       last_subvector[bi]=~|count[bi*(LOG2MVL-LOG2NUMLANES+1)+:LOG2MVL-LOG2NUMLANES];
       alive_s3[bi]=~count[(bi+1)*(LOG2MVL-LOG2NUMLANES+1)-1];
 
@@ -8903,12 +8949,14 @@
           ~((first_subvector[bi]) && 
               i<`LO(rdelm[bi*LOG2MVL +: LOG2MVL],LOG2NUMLANES) ||
             (last_subvector[bi]) && 
-              i>src_limit_s3[((bi-0)*((LOG2MVL-1)-(0)+1)+LOG2MVL-1-0) : ((bi-0)*((LOG2MVL-1)-(0)+1))][((LOG2NUMLANES>0) ? LOG2NUMLANES : 1)-1:0] );
+              i>( LOG2NUMLANES>0?(src_limit_s3[(bi*LOG2NUMLANES)+LOG2NUMLANES-1:(bi*LOG2NUMLANES)]):
+                                 src_limit_s3[bi*LOG2NUMLANES:bi*LOG2NUMLANES]));
     end
 
 
   // ************* Map from issuer to register file banks *************
-  always@*
+  
+  always@* //NUMBANKS=1 for now, hence removing for loop
     for (b=0; b<NUMBANKS; b=b+1)
     begin 
       dst_s3[((b-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((b-0)*((REGIDWIDTH-1)-(0)+1))]=_dst_s3[((b-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((b-0)*((REGIDWIDTH-1)-(0)+1))] | (wrelm[b*LOG2MVL+:LOG2MVL]>>LOG2NUMLANES);
@@ -8917,15 +8965,14 @@
       src2_s3[((b-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((b-0)*((REGIDWIDTH-1)-(0)+1))]=_src2_s3[((b-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((b-0)*((REGIDWIDTH-1)-(0)+1))] | (rdelm[b*LOG2MVL+:LOG2MVL]>>LOG2NUMLANES);
 
       wrongbank_s3[b]=(`LO(rdelm[b*LOG2MVL+:LOG2MVL]>>LOG2NUMLANES,LOG2NUMBANKS)!=b);
-
+      //taking in values into the vector registers
       vr_a_reg[b*BANKREGIDWIDTH +: BANKREGIDWIDTH]=src1_s3[((b-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((b-0)*((REGIDWIDTH-1)-(0)+1))]>>LOG2NUMBANKS;
       vr_b_reg[b*BANKREGIDWIDTH +: BANKREGIDWIDTH]=src2_s3[((b-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((b-0)*((REGIDWIDTH-1)-(0)+1))]>>LOG2NUMBANKS;
       vr_a_en[b]=ctrl3_vr_a_en[b] && pipe_advance[3];
       vr_b_en[b]=ctrl3_vr_b_en[b] && pipe_advance[3];
 
-      vf_a_reg[b*BANKREGIDWIDTH +: BANKREGIDWIDTH]= 
-        {(ctrl3_vf_a_sel[b]) ? _src1_s3[((b-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((b-0)*((REGIDWIDTH-1)-(0)+1))][`VRID_RANGE] : imask_s3[b],
-        src1_s3[((b-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((b-0)*((REGIDWIDTH-1)-(0)+1))][`VRELM_RANGE]}>>LOG2NUMBANKS;
+      vf_a_reg[b*BANKREGIDWIDTH +: BANKREGIDWIDTH]= {(ctrl3_vf_a_sel[b]) ? _src1_s3[(b*REGIDWIDTH)+REGIDWIDTH-1:b*(REGIDWIDTH)+REGIDWIDTH-5] : imask_s3[b],
+                                                                                      src1_s3[b*(REGIDWIDTH)+REGIDWIDTH-VRIDWIDTH-1:0]}>>LOG2NUMBANKS;
       vf_b_reg[b*BANKREGIDWIDTH +: BANKREGIDWIDTH]=src2_s3[((b-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((b-0)*((REGIDWIDTH-1)-(0)+1))]>>LOG2NUMBANKS;
       vf_a_en[b]=ctrl3_vf_a_en[b] && pipe_advance[3];
       vf_b_en[b]=ctrl3_vf_b_en[b] && pipe_advance[3];
@@ -8979,7 +9026,7 @@
         D_last_subvector_s4[f3]=0;
         dst_s4[((f3-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((f3-0)*((REGIDWIDTH-1)-(0)+1))]=0;
       end
-
+      //Controls will go to different functional units based on the enale signal
       for (b3=0; b3<NUMBANKS; b3=b3+1)
       begin
         //if instruction is alive && is in correct bank
@@ -8991,13 +9038,13 @@
             D_instr_s4[((FU_MUL-0)*((7)-(0)+1)+7-0) : ((FU_MUL-0)*((7)-(0)+1))]=D_instr_s3[((b3-0)*((7)-(0)+1)+7-0) : ((b3-0)*((7)-(0)+1))];
             D_last_subvector_s4[FU_MUL]=last_subvector[b3];
             ctrl4_mulshift_en=ctrl3_mulshift_en[b3];
-            banksel_s4[((FU_MUL-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_MUL-0)*((NUMBANKS-1)-(0)+1))]=b3;
+            banksel_s4[((FU_MUL-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_MUL-0)*((NUMBANKS-1)-(0)+1))]=b3; //since non blocking statement taking from the last bank
             vs_s4[((FU_MUL-0)*((VSWIDTH-1)-(0)+1)+VSWIDTH-1-0) : ((FU_MUL-0)*((VSWIDTH-1)-(0)+1))]=vs_s3[((b3-0)*((VSWIDTH-1)-(0)+1)+VSWIDTH-1-0) : ((b3-0)*((VSWIDTH-1)-(0)+1))];
             vc_s4[((FU_MUL-0)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((FU_MUL-0)*((VCWIDTH-1)-(0)+1))]=vc_s3[((b3-0)*((VCWIDTH-1)-(0)+1)+VCWIDTH-1-0) : ((b3-0)*((VCWIDTH-1)-(0)+1))];
             dst_s4[((FU_MUL-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((FU_MUL-0)*((REGIDWIDTH-1)-(0)+1))]=dst_s3[((b3-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((b3-0)*((REGIDWIDTH-1)-(0)+1))];
             dst_we_s4[FU_MUL]=ctrl3_vr_c_we[b3];
             vlane_en[((FU_MUL-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_MUL-0)*((NUMLANES-1)-(0)+1))]=lane_en[((b3-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((b3-0)*((NUMLANES-1)-(0)+1))];
-            src1scalar_s4[FU_MUL]=src1scalar_s3[b3];
+            src1scalar_s4[FU_MUL]=src1scalar_s3[b3]; //can take scalars as inputs as well
             src2scalar_s4[FU_MUL]=src2scalar_s3[b3];
             ctrl4_ismasked[FU_MUL]=ctrl3_ismasked[b3];
             ctrl4_mulshift_op=ctrl3_mulshift_op[((b3-0)*((4)-(0)+1)+4-0) : ((b3-0)*((4)-(0)+1))];
@@ -9048,7 +9095,7 @@
             src2scalar_s4[FU_BFMULT]=src2scalar_s3[b3];
             ctrl4_ismasked[FU_BFMULT]=ctrl3_ismasked[b3];
           end
-          else if (ctrl3_transpose_en[b3])    //is bfloat addition
+          else if (ctrl3_transpose_en[b3])    //is transpose
           begin
             D_instr_s4[((FU_TRANSPOSE-0)*((7)-(0)+1)+7-0) : ((FU_TRANSPOSE-0)*((7)-(0)+1))]=D_instr_s3[((b3-0)*((7)-(0)+1)+7-0) : ((b3-0)*((7)-(0)+1))];
             D_last_subvector_s4[FU_TRANSPOSE]=last_subvector[b3];
@@ -9063,11 +9110,11 @@
             src2scalar_s4[FU_TRANSPOSE]=src2scalar_s3[b3];
             ctrl4_ismasked[FU_TRANSPOSE]=ctrl3_ismasked[b3];
           end
-          else if (ctrl3_permute_en[b3])    //is bfloat addition
+          else if (ctrl3_permute_en[b3])    //is permute operation
           begin
             D_instr_s4[((FU_PERMUTE-0)*((7)-(0)+1)+7-0) : ((FU_PERMUTE-0)*((7)-(0)+1))]=D_instr_s3[((b3-0)*((7)-(0)+1)+7-0) : ((b3-0)*((7)-(0)+1))];
             D_last_subvector_s4[FU_PERMUTE]=last_subvector[b3];
-            ctrl4_permute_en = ctrl3_permute_en[b3];
+            ctrl4_permute_en = ctrl3_permute_en[b3]; 
             ctrl4_permute_op = ctrl3_permute_op;
             ctrl4_permute_store = ctrl3_permute_store;
             ctrl4_permute_read = ctrl3_permute_read;
@@ -9081,7 +9128,7 @@
             src2scalar_s4[FU_PERMUTE]=src2scalar_s3[b3];
             ctrl4_ismasked[FU_PERMUTE]=ctrl3_ismasked[b3];
           end
-          else if (ctrl3_trp_en[b3])    //is bfloat addition
+          else if (ctrl3_trp_en[b3])    //is trp unit
           begin
             D_instr_s4[((FU_TRP-0)*((7)-(0)+1)+7-0) : ((FU_TRP-0)*((7)-(0)+1))]=D_instr_s3[((b3-0)*((7)-(0)+1)+7-0) : ((b3-0)*((7)-(0)+1))];
             D_last_subvector_s4[FU_TRP]=last_subvector[b3];
@@ -9097,7 +9144,7 @@
             src2scalar_s4[FU_TRP]=src2scalar_s3[b3];
             ctrl4_ismasked[FU_TRP]=ctrl3_ismasked[b3];
           end
-          else if (ctrl3_act_en[b3])    //is bfloat addition
+          else if (ctrl3_act_en[b3])    //is activation
           begin
             D_instr_s4[((FU_ACT-0)*((7)-(0)+1)+7-0) : ((FU_ACT-0)*((7)-(0)+1))]=D_instr_s3[((b3-0)*((7)-(0)+1)+7-0) : ((b3-0)*((7)-(0)+1))];
             D_last_subvector_s4[FU_ACT]=last_subvector[b3];
@@ -9211,7 +9258,7 @@
         end
       end
 
-
+  //vector register 
   vregfile_vector 
     #(NUMBANKS,LOG2NUMBANKS,8*VPW*NUMLANES,32*MVL/NUMLANES,REGIDWIDTH) 
     vregfile_vector (
@@ -9274,9 +9321,9 @@
   begin
     for (fn=0; fn<=FU_MUL; fn=fn+1)
     begin
-      vr_src1[fn] =(src1scalar_s4[fn]) ? {NUMLANES{vs_s4[((fn-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((fn-0)*((VSWIDTH-1)-(0)+1))]}} : 
+      vr_src1[fn*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src1scalar_s4[fn]) ? {NUMLANES{vs_s4[((fn-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((fn-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_a_readdataout[banksel_s4[((fn-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((fn-0)*((NUMBANKS-1)-(0)+1))]];
-      vr_src2[fn] =(src2scalar_s4[fn]) ? {NUMLANES{vs_s4[((fn-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((fn-0)*((VSWIDTH-1)-(0)+1))]}} : 
+      vr_src2[fn*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src2scalar_s4[fn]) ? {NUMLANES{vs_s4[((fn-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((fn-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_b_readdataout[banksel_s4[((fn-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((fn-0)*((NUMBANKS-1)-(0)+1))]];
       vf_src1[((fn-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((fn-0)*((NUMLANES-1)-(0)+1))] = vf_a_readdataout[banksel_s4[((fn-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((fn-0)*((NUMBANKS-1)-(0)+1))]*NUMLANES +: NUMLANES];
 
@@ -9292,29 +9339,32 @@
            ((ctrl4_ismasked[FU_MEM]) ?  
              vf_a_readdataout[banksel_s4[((FU_MEM-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_MEM-0)*((NUMBANKS-1)-(0)+1))]*NUMLANES +: NUMLANES] :
              {NUMLANES{1'b1}}) ;
-
-    vr_src1[FU_MATMUL] =(src1scalar_s4[FU_MATMUL]) ? {NUMLANES{vs_s4[((FU_MATMUL-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_MATMUL-0)*((VSWIDTH-1)-(0)+1))]}} : 
+    //source operand for the functional units, whether from vector register file or the scalar source
+    //for scalar replicate the same data across all the lanes
+    vr_src1[FU_MATMUL*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src1scalar_s4[FU_MATMUL]) ? {NUMLANES{vs_s4[((FU_MATMUL-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_MATMUL-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_a_readdataout[banksel_s4[((FU_MATMUL-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_MATMUL-0)*((NUMBANKS-1)-(0)+1))]];
-    vr_src2[FU_MATMUL] =(src2scalar_s4[FU_MATMUL]) ? {NUMLANES{vs_s4[((FU_MATMUL-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_MATMUL-0)*((VSWIDTH-1)-(0)+1))]}} : 
+    vr_src2[FU_MATMUL*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src2scalar_s4[FU_MATMUL]) ? {NUMLANES{vs_s4[((FU_MATMUL-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_MATMUL-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_b_readdataout[banksel_s4[((FU_MATMUL-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_MATMUL-0)*((NUMBANKS-1)-(0)+1))]];
-    vr_src1[FU_BFADDER] =(src1scalar_s4[FU_BFADDER]) ? {NUMLANES{vs_s4[((FU_BFADDER-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_BFADDER-0)*((VSWIDTH-1)-(0)+1))]}} : 
+    vr_src1[FU_BFADDER*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src1scalar_s4[FU_BFADDER]) ? {NUMLANES{vs_s4[((FU_BFADDER-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_BFADDER-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_a_readdataout[banksel_s4[((FU_BFADDER-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_BFADDER-0)*((NUMBANKS-1)-(0)+1))]];
-    vr_src2[FU_BFADDER] =(src2scalar_s4[FU_BFADDER]) ? {NUMLANES{vs_s4[((FU_BFADDER-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_BFADDER-0)*((VSWIDTH-1)-(0)+1))]}} : 
+    vr_src2[FU_BFADDER*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src2scalar_s4[FU_BFADDER]) ? {NUMLANES{vs_s4[((FU_BFADDER-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_BFADDER-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_b_readdataout[banksel_s4[((FU_BFADDER-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_BFADDER-0)*((NUMBANKS-1)-(0)+1))]];
-    vr_src1[FU_BFMULT] =(src1scalar_s4[FU_BFMULT]) ? {NUMLANES{vs_s4[((FU_BFMULT-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_BFMULT-0)*((VSWIDTH-1)-(0)+1))]}} : 
+    vr_src1[FU_BFMULT*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src1scalar_s4[FU_BFMULT]) ? {NUMLANES{vs_s4[((FU_BFMULT-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_BFMULT-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_a_readdataout[banksel_s4[((FU_BFMULT-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_BFMULT-0)*((NUMBANKS-1)-(0)+1))]];
-    vr_src2[FU_BFMULT] =(src2scalar_s4[FU_BFMULT]) ? {NUMLANES{vs_s4[((FU_BFMULT-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_BFMULT-0)*((VSWIDTH-1)-(0)+1))]}} : 
+    vr_src2[FU_BFMULT*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src2scalar_s4[FU_BFMULT]) ? {NUMLANES{vs_s4[((FU_BFMULT-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_BFMULT-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_b_readdataout[banksel_s4[((FU_BFMULT-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_BFMULT-0)*((NUMBANKS-1)-(0)+1))]];
-    vr_src1[FU_TRP] =(src1scalar_s4[FU_TRP]) ? {NUMLANES{vs_s4[((FU_TRP-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_TRP-0)*((VSWIDTH-1)-(0)+1))]}} : 
+    vr_src1[FU_TRP*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src1scalar_s4[FU_TRP]) ? {NUMLANES{vs_s4[((FU_TRP-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_TRP-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_a_readdataout[banksel_s4[((FU_TRP-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_TRP-0)*((NUMBANKS-1)-(0)+1))]];
-    vr_src1[FU_TRANSPOSE] =(src1scalar_s4[FU_TRANSPOSE]) ? {NUMLANES{vs_s4[((FU_TRANSPOSE-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_TRANSPOSE-0)*((VSWIDTH-1)-(0)+1))]}} : 
+    vr_src1[FU_TRANSPOSE*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src1scalar_s4[FU_TRANSPOSE]) ? {NUMLANES{vs_s4[((FU_TRANSPOSE-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_TRANSPOSE-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_a_readdataout[banksel_s4[((FU_TRANSPOSE-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_TRANSPOSE-0)*((NUMBANKS-1)-(0)+1))]];
-    vr_src1[FU_PERMUTE] =(src1scalar_s4[FU_PERMUTE]) ? {NUMLANES{vs_s4[((FU_PERMUTE-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_PERMUTE-0)*((VSWIDTH-1)-(0)+1))]}} : 
+    vr_src1[FU_PERMUTE*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src1scalar_s4[FU_PERMUTE]) ? {NUMLANES{vs_s4[((FU_PERMUTE-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_PERMUTE-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_b_readdataout[banksel_s4[((FU_PERMUTE-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_PERMUTE-0)*((NUMBANKS-1)-(0)+1))]];
-    vr_src1[FU_AXI] =(src1scalar_s4[FU_AXI]) ? {NUMLANES{vs_s4[((FU_AXI-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_AXI-0)*((VSWIDTH-1)-(0)+1))]}} : 
+    vr_src1[FU_AXI*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src1scalar_s4[FU_AXI]) ? {NUMLANES{vs_s4[((FU_AXI-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_AXI-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_b_readdataout[banksel_s4[((FU_AXI-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_AXI-0)*((NUMBANKS-1)-(0)+1))]];
-    vr_src1[FU_ACT] =(src1scalar_s4[FU_ACT]) ? {NUMLANES{vs_s4[((FU_ACT-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_ACT-0)*((VSWIDTH-1)-(0)+1))]}} : 
+    vr_src1[FU_ACT*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES] =(src1scalar_s4[FU_ACT]) ? {NUMLANES{vs_s4[((FU_ACT-0)*((VSWIDTH-1)-(0)+1)+LANEWIDTH-1-0) : ((FU_ACT-0)*((VSWIDTH-1)-(0)+1))]}} : 
                                     vr_a_readdataout[banksel_s4[((FU_ACT-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_ACT-0)*((NUMBANKS-1)-(0)+1))]];
+    
+    //TODO: change it, don't use vf_a.. i.e flag registers for creating this mask
     vmask[((FU_MATMUL-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_MATMUL-0)*((NUMLANES-1)-(0)+1))] =  vlane_en[((FU_MATMUL-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_MATMUL-0)*((NUMLANES-1)-(0)+1))] &
            ((ctrl4_ismasked[FU_MATMUL]) ?  
              vf_a_readdataout[banksel_s4[((FU_MATMUL-0)*((NUMBANKS-1)-(0)+1)+NUMBANKS-1-0) : ((FU_MATMUL-0)*((NUMBANKS-1)-(0)+1))]*NUMLANES +: NUMLANES] :
@@ -9413,7 +9463,7 @@
 )inst_axi_master
 (
     .req_addr      (vbase_s4[10:0]),
-    .req_data      (vr_src1[((FU_AXI-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_AXI-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))]),
+    .req_data      (vr_src1[FU_AXI*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES]),
     .req_en        (ctrl4_axi_en),
     .req_type      (ctrl4_axi_req_type),
     .req_read_data (axi_out),
@@ -9541,29 +9591,35 @@
  wire squash_per_lane_mem_dstpipe_NC;
  wire squash_per_lane_mem_dstmask_NC;
 
+//destination value
 pipe #(REGIDWIDTH,3) lane_mem_dstpipe (
   .d( dst_s4[((FU_MEM-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((FU_MEM-0)*((REGIDWIDTH-1)-(0)+1))] ),  
   .clk(clk),
   .resetn(resetn),
   .en( pipe_advance[6:4] ),
   .squash(squash_per_lane_mem_dstpipe_NC),
-  .q({dst[FU_MEM][7],dst[FU_MEM][6],dst[FU_MEM][5],dst[FU_MEM][4]}));
 
+  .q(dst[(`MAX_STAGES-4)*(FU_MATMUL*REGIDWIDTH)+ 4*REGIDWIDTH-1: 
+     (`MAX_STAGES-4)*(FU_MATMUL*REGIDWIDTH)]));
+    
+//for write enable
 pipe #(1,3) lane_mem_dstwepipe (
   .d( dst_we_s4[FU_MEM]),  
   .clk(clk),
   .resetn(resetn),
   .en( pipe_advance[6:4] ),
   .squash( pipe_squash[6:4] ),
-  .q({dst_we[((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1)+7-7) : ((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1))],dst_we[((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1)+6-6) : ((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1))],dst_we[((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1))],dst_we[((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1))]}));
+  .q(dst_we[FU_MEM*(`MAX_STAGES-4)+3-:4]));
 
+//if a lane is masked, you won't write into that lane
 pipe #(NUMLANES,3) lane_mem_dstmaskpipe (
   .d( vmask[((FU_MEM-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_MEM-0)*((NUMLANES-1)-(0)+1))]),  
   .clk(clk),
   .resetn(resetn),
   .en( pipe_advance[4] ),
   .squash(squash_per_lane_mem_dstmask_NC),
-  .q({dst_mask[FU_MEM][7],dst_mask[FU_MEM][6],dst_mask[FU_MEM][5],dst_mask[FU_MEM][4]}));
+
+  .q(dst_mask[FU_MEM*(`MAX_STAGES-4)+4*(NUM_LANES)-1-:4*NUM_LANES]));
 
 wire     [ LANEWIDTH*NUMLANES-1 : 0 ]   load_mem_result_s5;
 
@@ -9572,7 +9628,8 @@
 wire [NUMLANES-1:0] mux_lane_rden, mux_lane_wren;
 wire [NUMLANES-1:0] dma_lane_rden,dma_lane_wren;
 
-
+ //choose data from axi or dma
+ //can read and write through axi (the master will initiaite the transactions)
  dma_axi_mux#(
    .WIDTH(LANEWIDTH),
    .NUMLANES(NUMLANES),
@@ -9602,7 +9659,7 @@
    .op(ctrl4_memunit_op),
    .address_a(vbase_s4[10:0]),
    .stride_val_a(vstrideoffset_s4[VCWIDTH-1:0]),
-   .offset_a(vr_src1[((FU_MEM-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_MEM-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))]),
+   .offset_a(vr_src1[FU_MEM*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES]),
    .data_a(vr_src2[((FU_MEM-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_MEM-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))]),
    .out_a(load_mem_result_s5),
    .last_subvector(mem_last_subvector_s4),
@@ -9644,7 +9701,7 @@
    .dbus_wait      (dma_dbus_wait      ),
    .dbus_data_valid(dma_dbus_data_valid)
   );
-
+  //TODO: remove vmem unit since it is not used
   vmem_unit vmem_unit(
     .clk(clk),
     .resetn(resetn),
@@ -9661,7 +9718,7 @@
     // Vector ports
     .vmask(vmask[((FU_MEM-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_MEM-0)*((NUMLANES-1)-(0)+1))]),
     .vstrideoffset(vstrideoffset_s4),
-    .vindex(vr_src1[((FU_MEM-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_MEM-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))]),
+    .vindex(vr_src1[FU_MEM*LANEWIDTH*NUMLANES+LANEWIDTH*NUMLANES-1-:LANEWIDTH*NUMLANES]),
     .vwritedata(vr_src2[((FU_MEM-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_MEM-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))]),
     .voutput(load_result_s5),
     .voutput_we(load_result_mask_s5),
@@ -9703,11 +9760,11 @@
     vmem_unit.ELMIDWIDTH=REGIDWIDTH-VRIDWIDTH,
     vmem_unit.REGIDWIDTH=REGIDWIDTH;
 
-  assign dst[FU_MEM][4]=dst_s4[FU_MEM];
-  assign dst_we[((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1))]=dst_we_s4[FU_MEM];
+  assign dst[(`MAX_STAGES-4)*(FU_MEM*REGIDWIDTH) +REGIDWIDTH-1:(`MAX_STAGES-4)*(FU_MEM*REGIDWIDTH) ]=dst_s4[FU_MEM];
+  assign dst_we[FU_MEM*(`MAX_STAGES-4)]=dst_we_s4[FU_MEM];
 
   //============== Multiplier Unit (spans stages 4-6) =============
-
+  wire [3*REGIDWIDTH-1:0] temp_vmul_dst;
   vmul_unit vmul_unit(
     .clk(clk),
     .resetn(resetn),
@@ -9722,9 +9779,10 @@
     .vmask(vmask[((FU_MUL-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_MUL-0)*((NUMLANES-1)-(0)+1))]),
     .in_dst(dst_s4[((FU_MUL-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((FU_MUL-0)*((REGIDWIDTH-1)-(0)+1))]),
     .in_dst_we(dst_we_s4[FU_MUL]),
-    .out_dst({dst[FU_MUL][6],dst[FU_MUL][5],dst[FU_MUL][4]}),
-    .out_dst_we(dst_we[((FU_MUL-0)*((`MAX_STAGES-1)-(4)+1)+6-4) : ((FU_MUL-0)*((`MAX_STAGES-1)-(4)+1))]),
-    .out_dst_mask({dst_mask[FU_MUL][6],dst_mask[FU_MUL][5],dst_mask[FU_MUL][4]}),
+    .out_dst(temp_vmul_dst),
+    .out_dst_we(dst_we[(FU_MUL)*(`MAX_STAGES-4)+2+1-1-:3]),
+
+    .out_dst_mask(dst_mask[FU_MUL*(`MAX_STAGES-4)+3*(NUM_LANES)-1-:3*NUM_LANES]),
     .result(mulshift_result_s5)
   );
   defparam 
@@ -9733,10 +9791,13 @@
     vmul_unit.LOG2NUMLANES=LOG2NUMLANES, // Number of vector lanes
     vmul_unit.REGIDWIDTH=REGIDWIDTH;
 
+  assign dst[(`MAX_STAGES-4)*(FU_MUL*REGIDWIDTH)+ 3*REGIDWIDTH -1: (`MAX_STAGES-4)*(FU_MUL*REGIDWIDTH)] = temp_vmul_dst[3*REGIDWIDTH-1:2*REGIDWIDTH] ;
+  assign dst[(`MAX_STAGES-4)*(FU_MUL*REGIDWIDTH)+ 2*REGIDWIDTH -1: (`MAX_STAGES-4)*(FU_MUL*REGIDWIDTH)] = temp_vmul_dst[2*REGIDWIDTH-1:1*REGIDWIDTH] ;
+  assign dst[(`MAX_STAGES-4)*(FU_MUL*REGIDWIDTH)+ REGIDWIDTH-1: (`MAX_STAGES-4)*(FU_MUL*REGIDWIDTH)] = temp_vmul_dst[1*REGIDWIDTH-1:0*REGIDWIDTH] ;
   //============== ALU Unit =============
 
   //If APB value is true, create one ALU per bank (per lane)
-
+  wire alu_cmpresult_s4_temp;
   generate
   for (bk=0; bk<1+(NUMBANKS-1)*ALUPERBANK; bk=bk+1)
   begin : aluperbank_gen
@@ -9748,21 +9809,22 @@
         .resetn(resetn),
         .pipe_en(pipe_advance[4]),
         .pipe_squashn(~pipe_squash[4]),
-        .src1(vr_src1[FU_ALU+bk][LANEWIDTH*k +: LANEWIDTH]),
-        .src2(vr_src2[FU_ALU+bk][LANEWIDTH*k +: LANEWIDTH]),
-        .mask(vf_src1[FU_ALU+bk][k]),  //Note: MERGE is not masked
+        .src1(vr_src1[(FU_ALU+bk)*(LANEWIDTH*NUMLANES)+LANEWIDTH*k -1 +:LANEWIDTH]),
+        .src2(vr_src2[(FU_ALU+bk)*(LANEWIDTH*NUMLANES)+LANEWIDTH*k -1 +:LANEWIDTH]),
+        .mask(vf_src1[(FU_ALU+bk)*(LANEWIDTH*NUMLANES)+k-1-:1]),  //Note: MERGE is not masked
         .op(ctrl4_alu_op[((bk-0)*((10)-(0)+1)+10-0) : ((bk-0)*((10)-(0)+1))]^ALUOP_ZERO),
         .satsum_op(ctrl4_satsum_op[((bk-0)*((1)-(0)+1)+1-0) : ((bk-0)*((1)-(0)+1))]),
         .satsize_op(ctrl4_satsize_op[((bk-0)*((3)-(0)+1)+3-0) : ((bk-0)*((3)-(0)+1))]),
-        .cmp_result(alu_cmpresult_s4[((bk-0)*((NUMLANES-1)-(0)+1)+k-k) : ((bk-0)*((NUMLANES-1)-(0)+1))]),
+        .cmp_result(alu_cmpresult_s4_temp),
         .result(alu_result_s5[((bk-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)) +: ( LANEWIDTH)])
         );
+      assign alu_cmpresult_s4[((bk-0)*((NUMLANES-1)-(0)+1)+k)]= alu_cmpresult_s4_temp;
 
       vlane_flagalu vflagalu(
         .clk(clk), 
         .resetn(resetn),
-        .src1(vf_src1[FU_FALU+bk][k]),
-        .src2(vf_src2[FU_FALU+bk][k]),
+        .src1(vf_src1[(FU_FALU+bk)*(LANEWIDTH*NUMLANES)+k-1-:1]),
+        .src2(vf_src2[(FU_FALU+bk)*(LANEWIDTH*NUMLANES)+k-1-:1]),
         .op(ctrl4_flagalu_op[((bk-0)*((2)-(0)+1)+2-0) : ((bk-0)*((2)-(0)+1))]),
         .result(flagalu_result_s4[((bk-0)*((NUMLANES-1)-(0)+1)+k-k) : ((bk-0)*((NUMLANES-1)-(0)+1))])
         );
@@ -9779,13 +9841,14 @@
     end
 
     wire squash_aludstpipe_NC;
+    wire [REGIDWIDTH*(1+1)-1:0] aludstpipe_bk_q;
     pipe #(REGIDWIDTH,1) aludstpipe (
       .d( dst_s4[FU_ALU+bk] ),  
       .clk(clk),
       .resetn(resetn),
       .en( pipe_advance[4] ),
       .squash(squash_aludstpipe_NC),
-      .q({dst[FU_ALU+bk][5],dst[FU_ALU+bk][4]}));
+      .q(dst[(`MAX_STAGES-4)*(FU_ALU+bk)*REGIDWIDTH+ 2*REGIDWIDTH -1-: 2*REGIDWIDTH]));
 
     pipe #(1,3) aludstwepipe (
       .d( dst_we_s4[FU_ALU+bk] & ~ctrl4_vf_wbsel[bk] ),  
@@ -9793,8 +9856,10 @@
       .resetn(resetn),
       .en( pipe_advance[6:4] ),
       .squash( pipe_squash[6:4] ),
-      .q({dst_we[FU_ALU+bk][5],dst_we[FU_ALU+bk][4]}));
-
+      .q(dst_we[(`MAX_STAGES-4)*(FU_ALU+bk)+1+1-1 -:2]));
+  
+           
+    
     wire squash_aludstmaskpipe_NC;
     pipe #(NUMLANES,1) aludstmaskpipe (
       .d( vmask[FU_ALU+bk] ),  
@@ -9802,24 +9867,27 @@
       .resetn(resetn),
       .en( pipe_advance[4] ),
       .squash(squash_aludstmaskpipe_NC),
-      .q({dst_mask[FU_ALU+bk][5],dst_mask[FU_ALU+bk][4]}));
+      .q(dst_mask[(FU_ALU+bk)*(`MAX_STAGES-4)+2*(NUM_LANES)-1-:2*NUM_LANES]));
 
     wire squash_faludstpipe_NC;
+    wire [REGIDWIDTH*(1+1)-1:0] faludstpipe_bk_q;
     pipe #(REGIDWIDTH,1) faludstpipe (
       .d( dst_s4[FU_FALU+bk] ),  
       .clk(clk),
       .resetn(resetn),
       .en( pipe_advance[4] ),
       .squash(squash_faludstpipe_NC),
-      .q({dst[FU_FALU+bk][5],dst[FU_FALU+bk][4]}));
+      .q(dst[(`MAX_STAGES-4)*(FU_FALU+bk)*REGIDWIDTH+ 2*REGIDWIDTH-1-: 2*REGIDWIDTH]));
+    
 
+    wire[1:0] faludstwepipe_bk_q;
     pipe #(1,3) faludstwepipe (
       .d( dst_we_s4[FU_FALU+bk] ),  
       .clk(clk),
       .resetn(resetn),
       .en( pipe_advance[6:4] ),
       .squash( pipe_squash[6:4] ),
-      .q({dst_we[FU_FALU+bk][5],dst_we[FU_FALU+bk][4]}));
+      .q(dst_we[(`MAX_STAGES-4)*(FU_FALU+bk)+1+1-1 -:2]));
   end
   endgenerate
 
@@ -9831,9 +9899,9 @@
  wire [NUMLANES-1:0] dst_we_matmul;
  wire [NUMLANES*NUMLANES-1:0] dst_mask_matmul;
 
- assign dst[FU_MATMUL][4] = dst_matmul[(REGIDWIDTH*NUMLANES)-1:REGIDWIDTH*(NUMLANES-1)];
- assign dst_mask[FU_MATMUL][4] = dst_mask_matmul[(NUMLANES*NUMLANES)-1:NUMLANES*(NUMLANES-1)];
- assign dst_we[((FU_MATMUL-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_MATMUL-0)*((`MAX_STAGES-1)-(4)+1))] = dst_we_matmul[NUMLANES-1];
+ assign dst[(`MAX_STAGES-4)*(FU_MATMUL)*REGIDWIDTH +REGIDWIDTH-1-:REGIDWIDTH] = dst_matmul[(REGIDWIDTH*NUMLANES)-1:REGIDWIDTH*(NUMLANES-1)];
+ assign dst_mask[FU_MATMUL*(`MAX_STAGES-4)+NUM_LANES-1-:NUM_LANES] = dst_mask_matmul[(NUMLANES*NUMLANES)-1:NUMLANES*(NUMLANES-1)];
+ assign dst_we[(FU_MATMUL)*(`MAX_STAGES-4)] = dst_we_matmul[NUMLANES-1];
 
 
 ///////////////////////////
@@ -9889,16 +9957,8 @@
   .resetn(resetn),
   .en(pipe_advance[12:4]),
   .squash(squash_transpose_dstpipe_NC),
-  .q({dst[FU_TRANSPOSE][13],
-      dst[FU_TRANSPOSE][12],
-      dst[FU_TRANSPOSE][11],
-      dst[FU_TRANSPOSE][10],
-      dst[FU_TRANSPOSE][9],
-      dst[FU_TRANSPOSE][8],
-      dst[FU_TRANSPOSE][7],
-      dst[FU_TRANSPOSE][6],
-      dst[FU_TRANSPOSE][5],
-      dst[FU_TRANSPOSE][4]}));
+  .q(dst[FU_TRANPOSE*((`MAX_STAGES-4)*REGIDWIDTH)+10*REGIDWIDTH -1-:10*REGIDWIDTH]));
+
 
 pipe #(1,9) transpose_dstwepipe (
   .d( dst_we_s4[FU_TRANSPOSE]),  
@@ -9908,16 +9968,9 @@
   .en(9'hff),
 //  .squash( pipe_squash[11:4] ),
   .squash(9'h00 ),
-  .q({dst_we[((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1)+13-13) : ((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1))],
-      dst_we[((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1)+12-12) : ((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1))],
-      dst_we[((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1)+11-11) : ((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1))],
-      dst_we[((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1)+10-10) : ((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1))],
-      dst_we[((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1)+9-9) : ((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1))],
-      dst_we[((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1)+8-8) : ((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1))],
-      dst_we[((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1)+7-7) : ((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1))],
-      dst_we[((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1)+6-6) : ((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1))],
-      dst_we[((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1))],
-      dst_we[((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1))]}));
+   
+  .q(dst_we[(FU_TRANSPOSE-0)*(`MAX_STAGES-4)+9+1-1:(FU_TRANSPOSE-0)*(`MAX_STAGES-4)]));
+
 
 pipe #(NUMLANES,9) transpose_dstmaskpipe (
   .d(vmask[((FU_TRANSPOSE-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_TRANSPOSE-0)*((NUMLANES-1)-(0)+1))]),  
@@ -9925,28 +9978,21 @@
   .resetn(resetn),
   .en(pipe_advance[12:4]),
   .squash(squash_transpose_dstmask_NC),
-  .q({dst_mask[FU_TRANSPOSE][13],
-      dst_mask[FU_TRANSPOSE][12],
-      dst_mask[FU_TRANSPOSE][11],
-      dst_mask[FU_TRANSPOSE][10],
-      dst_mask[FU_TRANSPOSE][9],
-      dst_mask[FU_TRANSPOSE][8],
-      dst_mask[FU_TRANSPOSE][7],
-      dst_mask[FU_TRANSPOSE][6],
-      dst_mask[FU_TRANSPOSE][5],
-      dst_mask[FU_TRANSPOSE][4]}));
+
+  .q(dst_mask[(FU_TRANSPOSE)*(`MAX_STAGES-4)+10*(NUM_LANES)-1-:10*NUM_LANES]));
 
 reg [3*NUMLANES-1:0] permute_row_col_vec;
 
 always@(*)begin
-  permute_row_col_vec[3*1-1:3*0] = vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))][0*LANEWIDTH+3 : 0*LANEWIDTH];
-  permute_row_col_vec[3*2-1:3*1] = vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))][1*LANEWIDTH+3 : 1*LANEWIDTH];
-  permute_row_col_vec[3*3-1:3*2] = vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))][2*LANEWIDTH+3 : 2*LANEWIDTH];
-  permute_row_col_vec[3*4-1:3*3] = vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))][3*LANEWIDTH+3 : 3*LANEWIDTH];
-  permute_row_col_vec[3*5-1:3*4] = vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))][4*LANEWIDTH+3 : 4*LANEWIDTH];
-  permute_row_col_vec[3*6-1:3*5] = vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))][5*LANEWIDTH+3 : 5*LANEWIDTH];
-  permute_row_col_vec[3*7-1:3*6] = vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))][6*LANEWIDTH+3 : 6*LANEWIDTH];
-  permute_row_col_vec[3*8-1:3*7] = vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))][7*LANEWIDTH+3 : 7*LANEWIDTH];
+
+  permute_row_col_vec[3*1-1:3*0] =vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+3-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))];
+  permute_row_col_vec[3*2-1:3*1] =vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES*1+3-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)+LANEWIDTH*NUMLANES*1-(0)+1))];
+  permute_row_col_vec[3*3-1:3*2] =vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES*2+3-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)+LANEWIDTH*NUMLANES*2-(0)+1))];
+  permute_row_col_vec[3*4-1:3*3] =vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES*3+3-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)+LANEWIDTH*NUMLANES*3-(0)+1))];
+  permute_row_col_vec[3*5-1:3*4] =vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES*4+3-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)+LANEWIDTH*NUMLANES*4-(0)+1))];
+  permute_row_col_vec[3*6-1:3*5] =vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES*5+3-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)+LANEWIDTH*NUMLANES*5-(0)+1))];
+  permute_row_col_vec[3*7-1:3*6] =vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES*6+3-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)+LANEWIDTH*NUMLANES*6-(0)+1))];
+  permute_row_col_vec[3*8-1:3*7] =vr_src1[((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES*7+3-1-0) : ((FU_PERMUTE-0)*((LANEWIDTH*NUMLANES-1)+LANEWIDTH*NUMLANES*7-(0)+1))];
 end
 
 wire [REGIDWIDTH-1:0] permute_dst;
@@ -10027,7 +10073,8 @@
   .resetn(resetn),
   .en(~trp_busy ),
   .squash(squash_trp_dstpipe_NC),
-  .q({dst[FU_TRP][6],dst[FU_TRP][5],dst[FU_TRP][4]}));
+  
+  .q(dst[(`MAX_STAGES-4)*(FU_TRP)*REGIDWIDTH+ 3*REGIDWIDTH-: 3*REGIDWIDTH]));
 
 pipe #(1,2) trp_dstwepipe (
   .d( dst_we_s4[FU_TRP]),  
@@ -10035,7 +10082,7 @@
   .resetn(resetn),
   .en(~trp_busy ),
   .squash( pipe_squash[4] ),
-  .q({dst_we[((FU_TRP-0)*((`MAX_STAGES-1)-(4)+1)+6-6) : ((FU_TRP-0)*((`MAX_STAGES-1)-(4)+1))],dst_we[((FU_TRP-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_TRP-0)*((`MAX_STAGES-1)-(4)+1))],dst_we[((FU_TRP-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_TRP-0)*((`MAX_STAGES-1)-(4)+1))]}));
+  .q(dst_we[(FU_TRP)*(`MAX_STAGES-4)+2+1-1:(FU_TRP)*(`MAX_STAGES-4)]));
 
 pipe #(NUMLANES,1) trp_dstmaskpipe (
   .d( vmask[((FU_TRP-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_TRP-0)*((NUMLANES-1)-(0)+1))]),  
@@ -10043,7 +10090,8 @@
   .resetn(resetn),
   .en(~trp_busy),
   .squash(squash_trp_dstmask_NC),
-  .q({dst_mask[FU_TRP][5],dst_mask[FU_TRP][4]}));
+
+  .q(dst_mask[(FU_TRP)*(`MAX_STAGES-4)+2*(NUM_LANES)-1-:2*NUM_LANES]));
 
 ///////////////////////////
 // Bfloat unit
@@ -10051,7 +10099,7 @@
 genvar g_func;
 wire[5*NUMLANES-1:0] bfadd_excp;
 wire[5*NUMLANES-1:0] bfmult_excp;
-wire bfadder_output_valid;
+wire [NUMLANES-1:0] bfadder_output_valid;
 wire [NUMLANES-1:0] bfmult_output_valid;
 
 wire squash_bfadder_dstmask_NC;
@@ -10068,15 +10116,16 @@
   .resetn(resetn),
   .en( pipe_advance[6:4] ),
   .squash(squash_bfadder_dstpipe_NC),
-  .q({dst[FU_BFADDER][7],dst[FU_BFADDER][6],dst[FU_BFADDER][5],dst[FU_BFADDER][4]}));
-
+  .q(dst[(`MAX_STAGES-4)*(FU_BFADDER)*REGIDWIDTH+ 4*REGIDWIDTH -1-: 4*REGIDWIDTH]
+));
+  
 pipe #(1,3) bfadddstwepipe (
   .d( dst_we_s4[FU_BFADDER]),  
   .clk(clk),
   .resetn(resetn),
   .en( pipe_advance[6:4] ),
   .squash( pipe_squash[6:4] ),
-  .q({dst_we[((FU_BFADDER-0)*((`MAX_STAGES-1)-(4)+1)+7-7) : ((FU_BFADDER-0)*((`MAX_STAGES-1)-(4)+1))],dst_we[((FU_BFADDER-0)*((`MAX_STAGES-1)-(4)+1)+6-6) : ((FU_BFADDER-0)*((`MAX_STAGES-1)-(4)+1))],dst_we[((FU_BFADDER-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_BFADDER-0)*((`MAX_STAGES-1)-(4)+1))],dst_we[((FU_BFADDER-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_BFADDER-0)*((`MAX_STAGES-1)-(4)+1))]}));
+  .q(dst_we[(FU_BFADDER)*(`MAX_STAGES-4)+3+1-1:(FU_BFADDER)*(`MAX_STAGES-4)]));
 
 pipe #(NUMLANES,3) bfadddstmaskpipe (
   .d( vmask[((FU_BFADDER-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_BFADDER-0)*((NUMLANES-1)-(0)+1))] ),  
@@ -10084,15 +10133,17 @@
   .resetn(resetn),
   .en( pipe_advance[6:4] ),
   .squash(squash_bfadder_dstmask_NC),
-  .q({dst[FU_BFMULT][7],dst[FU_BFMULT][6],dst_mask[FU_BFADDER][5],dst_mask[FU_BFADDER][4]}));
+  .q(dst_mask[(`MAX_STAGES-4)*(FU_BFADDER)*REGIDWIDTH+ 4*REGIDWIDTH -1-: 4*REGIDWIDTH]));
+  //above line different from original rtl , probably a small mistake
 
 pipe #(REGIDWIDTH,3) bfmultdstpipe (
-  .d( dst_s4[((FU_BFMULT-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((FU_BFMULT-0)*((REGIDWIDTH-1)-(0)+1))] ),  
+  .d( dst_s4[FU_BFMULT] ),  
   .clk(clk),
   .resetn(resetn),
   .en( pipe_advance[6:4] ),
   .squash(squash_per_lane_mem_NC),
-  .q({dst[FU_BFMULT][7],dst[FU_BFMULT][6],dst[FU_BFMULT][5],dst[FU_BFMULT][4]}));
+
+  .q(dst[(`MAX_STAGES-4)*(FU_BFMULT)*REGIDWIDTH+ 4*REGIDWIDTH -1-: 4*REGIDWIDTH]));
 
 pipe #(1,3) bfmultdstwepipe (
   .d( dst_we_s4[FU_BFMULT]),  
@@ -10100,15 +10151,16 @@
   .resetn(resetn),
   .en( pipe_advance[6:4] ),
   .squash( pipe_squash[6:4] ),
-  .q({dst_we[((FU_BFMULT-0)*((`MAX_STAGES-1)-(4)+1)+7-7) : ((FU_BFMULT-0)*((`MAX_STAGES-1)-(4)+1))],dst_we[((FU_BFMULT-0)*((`MAX_STAGES-1)-(4)+1)+6-6) : ((FU_BFMULT-0)*((`MAX_STAGES-1)-(4)+1))],dst_we[((FU_BFMULT-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_BFMULT-0)*((`MAX_STAGES-1)-(4)+1))],dst_we[((FU_BFMULT-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_BFMULT-0)*((`MAX_STAGES-1)-(4)+1))]}));
+
+  .q(dst_we[(FU_BFMULT)*(`MAX_STAGES-4)+3+1-1:(FU_BFMULT)*(`MAX_STAGES-4)]));
 
 pipe #(NUMLANES,3) bfmultdstmaskpipe (
-  .d( vmask[((FU_BFMULT-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_BFMULT-0)*((NUMLANES-1)-(0)+1))] ),  
+  .d( vmask[FU_BFMULT] ),  
   .clk(clk),
   .resetn(resetn),
   .en( pipe_advance[4] ),
   .squash(squash_bfmult_dstmask_NC),
-  .q({dst_mask[FU_BFMULT][7],dst_mask[FU_BFMULT][6],dst_mask[FU_BFMULT][5],dst_mask[FU_BFMULT][4]}));
+  .q(dst_mask[(`MAX_STAGES-4)*(FU_BFMULT)*NUMLANES+ 4*NUMLANES -1-: 4*NUMLANES]));
 
 pipe #(REGIDWIDTH,1) actdstpipe (
   .d( dst_s4[((FU_ACT-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((FU_ACT-0)*((REGIDWIDTH-1)-(0)+1))] ),  
@@ -10116,7 +10168,8 @@
   .resetn(resetn),
   .en( pipe_advance[5:4] ),
   .squash(squash_activation_dstpipe_NC),
-  .q({dst[FU_ACT][5],dst[FU_ACT][4]}));
+
+  .q(dst[(`MAX_STAGES-4)*(FU_ACT)*REGIDWIDTH+ 2*REGIDWIDTH -1-: 2*REGIDWIDTH]));
 
 pipe #(1,1) actdstwepipe (
   .d( dst_we_s4[FU_ACT]),  
@@ -10124,7 +10177,7 @@
   .resetn(resetn),
   .en( pipe_advance[5:4] ),
   .squash( pipe_squash[5:4] ),
-  .q({dst_we[((FU_ACT-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_ACT-0)*((`MAX_STAGES-1)-(4)+1))],dst_we[((FU_ACT-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_ACT-0)*((`MAX_STAGES-1)-(4)+1))]}));
+  .q(dst_we[(FU_ACT)*(`MAX_STAGES-4)+1+1-1:(FU_ACT)*(`MAX_STAGES-4)]));
 
 pipe #(NUMLANES,1) actdstmaskpipe (
   .d(vmask[((FU_ACT-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_ACT-0)*((NUMLANES-1)-(0)+1))]),  
@@ -10132,31 +10185,35 @@
   .resetn(resetn),
   .en( pipe_advance[5:4]),
   .squash(squash_activation_dstmask_NC),
-  .q({dst_mask[FU_ACT][5],dst_mask[FU_ACT][4]}));
 
-  generate
-  for(g_func =0; g_func <NUMLANES; g_func = g_func+1) begin
+  .q(dst_mask[(FU_ACT)*(`MAX_STAGES-4)+2*(NUM_LANES)-1-:2*NUM_LANES]));
+
+
+
+generate
+for(g_func =0; g_func <NUMLANES; g_func = g_func+1) begin
 
 FPAddSub bfloat_add(
-	.clk(clk),
-	.rst(~resetn),
-        .en(ctrl4_bfadder_en),
-	.a(vr_src1[((FU_BFADDER-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)) +: ( LANEWIDTH)]),
-	.b(vr_src2[((FU_BFADDER-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)) +: ( LANEWIDTH)]),
-	.operation(1'b0),
-	.result(bfadder_result_s5[g_func*LANEWIDTH +: LANEWIDTH]),
+  .clk(clk),
+  .rst(~resetn),
+  .en(ctrl4_bfadder_en),
+  .a(vr_src1[(FU_BFADDER)*(LANEWIDTH*NUMLANES)+(g_func)*LANEWIDTH+LANEWIDTH-1-:LANEWIDTH]),
+  .b(vr_src2[(FU_BFADDER)*(LANEWIDTH*NUMLANES)+(g_func)*LANEWIDTH+LANEWIDTH-1-:LANEWIDTH]),
+  .operation(1'b0),
+  .result(bfadder_result_s5[g_func*LANEWIDTH +: LANEWIDTH]),
         .valid(bfadder_output_valid[g_func]),
-	.flags(bfadd_excp[5*g_func +: 5]));
+  .flags(bfadd_excp[5*g_func +: 5]));
 
 FPMult_16 bfloat_mult(
-	.clk(clk),
-	.rst(~resetn),
-        .en(ctrl4_bfmult_en),
-	.a(vr_src1[((FU_BFMULT-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)) +: ( LANEWIDTH)]),
-	.b(vr_src1[((FU_BFMULT-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)) +: ( LANEWIDTH)]),
-	.result(bfmult_result_s5[g_func*LANEWIDTH +: LANEWIDTH]),
+  .clk(clk),
+  .rst(~resetn),
+  .en(ctrl4_bfmult_en),
+  .a(vr_src1[(FU_BFMULT)*(LANEWIDTH*NUMLANES)+(g_func)*LANEWIDTH+LANEWIDTH-1-:LANEWIDTH]),
+  .b(vr_src2[(FU_BFMULT)*(LANEWIDTH*NUMLANES)+(g_func)*LANEWIDTH+LANEWIDTH-1-:LANEWIDTH]),
+  .result(bfmult_result_s5[g_func*LANEWIDTH +: LANEWIDTH]),
         .valid(bfmult_output_valid[g_func]),
-	.flags(bfmult_excp[5*g_func +: 5]));
+  .flags(bfmult_excp[5*g_func +: 5]));
+
 
 
 //    bfloat_adder #(REGIDWIDTH) bf_add(
@@ -10188,58 +10245,58 @@
     .resetn(resetn),
     .en(ctrl4_act_en),
     .stall(stall_bf_adder),
-    .a(vr_src1[((FU_ACT-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)) +: ( LANEWIDTH)]),
+    .a(vr_src1[((FU_ACT-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)) +LANEWIDTH-1-: LANEWIDTH]),
     .out(act_result_s5[g_func*LANEWIDTH +: LANEWIDTH])
     );
   end
  endgenerate
 
-
 /******************************************************************************/
 /************************** WB Pipeline Stage ********************************/
 /******************************************************************************/
-
+  //taking the wb_dst from all the different units
   generate
   for (ba=0; ba<1+(NUMBANKS-1)*ALUPERBANK; ba=ba+1)
   begin : wbaluperbank_gen
-    assign wb_dst[FU_ALU+ba]=dst[FU_ALU+ba][5];
-    assign wb_dst_we[FU_ALU+ba]=dst_we[FU_ALU+ba][5] && ~pipe_squash[5];
-    assign wb_dst_mask[FU_ALU+ba]=dst_mask[FU_ALU+ba][5];
+
+    assign wb_dst[(FU_ALU+ba)*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH]=dst[(`MAX_STAGES-4)*(FU_ALU+ba)*REGIDWIDTH+ 2*REGIDWIDTH -1-:REGIDWIDTH];
+    assign wb_dst_we[FU_ALU+ba]=dst_we[(FU_ALU+ba)*(`MAX_STAGES-4)+1]  && ~pipe_squash[5];
+    assign wb_dst_mask[FU_ALU+ba]=dst_mask[(FU_ALU+ba)*(`MAX_STAGES-4)+2*(NUM_LANES)-1-:NUM_LANES];
     assign D_wb_last_subvector[FU_ALU+ba]=D_last_subvector_s5[FU_ALU+ba];
 
     assign D_wb_last_subvector[FU_FALU+ba]=D_last_subvector_s5[FU_FALU+ba];
   end
   endgenerate
 
-  assign wb_dst[FU_MEM]=dst[FU_MEM][5];
-  assign wb_dst_we[FU_MEM]=dst_we[((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1))] && (~pipe_advance[5]|~pipe_squash[5]);
-  assign wb_dst_mask[FU_MEM]=dst_mask[FU_MEM][5];
+  assign wb_dst[FU_MEM*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH]=dst[(`MAX_STAGES-4)*(FU_MEM)*REGIDWIDTH+ 2*REGIDWIDTH -1-:REGIDWIDTH];
+  assign wb_dst_we[FU_MEM]= dst_we[(FU_MEM)*(`MAX_STAGES-4)+1] && (~pipe_advance[5]|~pipe_squash[5]);
+  assign wb_dst_mask[FU_MEM]= dst_mask[(FU_MEM)*(`MAX_STAGES-4)+2*(NUM_LANES)-1-:NUM_LANES];
   assign D_wb_last_subvector[FU_MEM]=D_last_subvector_s5[FU_MEM];
 
-  assign wb_dst[FU_MUL]=dst[FU_MUL][5];
-  assign wb_dst_we[FU_MUL]=dst_we[((FU_MUL-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_MUL-0)*((`MAX_STAGES-1)-(4)+1))] && ~pipe_squash[5];
-  assign wb_dst_mask[FU_MUL]=dst_mask[FU_MUL][5];
+  assign wb_dst[FU_MUL*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH]=dst[(`MAX_STAGES-4)*(FU_MUL)*REGIDWIDTH+ 2*REGIDWIDTH -1-:REGIDWIDTH];
+  assign wb_dst_we[FU_MUL]=dst_we[(FU_MUL)*(`MAX_STAGES-4)+1+1-1-:1] && ~pipe_squash[5];
+  assign wb_dst_mask[FU_MUL]= dst_mask[(FU_MUL)*(`MAX_STAGES-4)+2*(NUM_LANES)-1-:NUM_LANES];
   assign D_wb_last_subvector[FU_MUL]=D_last_subvector_s5[FU_MUL];
 
 
-  assign wb_dst[FU_BFADDER] = dst[FU_BFADDER][7];
-  assign wb_dst_we[FU_BFADDER] = dst_we[((FU_BFADDER-0)*((`MAX_STAGES-1)-(4)+1)+7-7) : ((FU_BFADDER-0)*((`MAX_STAGES-1)-(4)+1))] && ~pipe_squash[7];
-  assign wb_dst_mask[FU_BFADDER] = dst_mask[FU_BFADDER][7];
+  assign wb_dst[FU_BFADDER*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH] = dst[(`MAX_STAGES-4)*(FU_BFADDER)*REGIDWIDTH+ 5*REGIDWIDTH -1-:REGIDWIDTH];
+  assign wb_dst_we[FU_BFADDER] = dst_we[(FU_BFADDER)*(`MAX_STAGES-4)+4] && ~pipe_squash[7];
+  assign wb_dst_mask[FU_BFADDER] = dst_mask[(FU_MUL)*(`MAX_STAGES-4)+5*(NUM_LANES)-1-:NUM_LANES];
   assign D_wb_last_subvector[FU_BFADDER] = D_last_subvector_s5[FU_BFADDER];
 
-  assign wb_dst[FU_BFMULT] = dst[FU_BFMULT][7];
-  assign wb_dst_we[FU_BFMULT] = dst_we[((FU_BFMULT-0)*((`MAX_STAGES-1)-(4)+1)+7-7) : ((FU_BFMULT-0)*((`MAX_STAGES-1)-(4)+1))] && ~pipe_squash[7];
-  assign wb_dst_mask[FU_BFMULT] = dst_mask[FU_BFMULT][7];
+  assign wb_dst[FU_BFMULT*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH] = dst[(`MAX_STAGES-4)*(FU_BFMULT)*REGIDWIDTH+ 5*REGIDWIDTH -1-:REGIDWIDTH];
+  assign wb_dst_we[FU_BFMULT] = dst_we[(FU_BFMULT)*(`MAX_STAGES-4)+4] && ~pipe_squash[7];
+  assign wb_dst_mask[FU_BFMULT] = dst_mask[(FU_BFMULT)*(`MAX_STAGES-4)+5*(NUM_LANES)-1-:NUM_LANES];
   assign D_wb_last_subvector[FU_BFMULT] = D_last_subvector_s5[FU_BFMULT];
 
-  assign wb_dst[FU_ACT] = dst[FU_ACT][5];
-  assign wb_dst_we[FU_ACT] = dst_we[((FU_ACT-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_ACT-0)*((`MAX_STAGES-1)-(4)+1))] && ~pipe_squash[5];
-  assign wb_dst_mask[FU_ACT] = dst_mask[FU_ACT][5];
+  assign wb_dst[FU_ACT*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH] = dst[(`MAX_STAGES-4)*(FU_ACT)*REGIDWIDTH+ 2*REGIDWIDTH -1-:REGIDWIDTH];
+  assign wb_dst_we[FU_ACT] = dst_we[(FU_ACT)*(`MAX_STAGES-4)+1]&& ~pipe_squash[5];
+  assign wb_dst_mask[FU_ACT] = dst_mask[(FU_ACT)*(`MAX_STAGES-4)+2*(NUM_LANES)-1-:NUM_LANES];
   assign D_wb_last_subvector[FU_ACT] = D_last_subvector_s5[FU_ACT];
 
-  assign wb_dst[FU_TRANSPOSE] = dst[FU_TRANSPOSE][13];
-  assign wb_dst_we[FU_TRANSPOSE] = dst_we[((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1)+13-13) : ((FU_TRANSPOSE-0)*((`MAX_STAGES-1)-(4)+1))];
-  assign wb_dst_mask[FU_TRANSPOSE] = dst_mask[FU_TRANSPOSE][13];
+  assign wb_dst[FU_TRANSPOSE*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH] = dst[(`MAX_STAGES-4)*(FU_TRANSPOSE)*REGIDWIDTH+ 10*REGIDWIDTH -1-:REGIDWIDTH];
+  assign wb_dst_we[FU_TRANSPOSE] = dst_we[(FU_TRANSPOSE)*(`MAX_STAGES-4)+9];
+  assign wb_dst_mask[FU_TRANSPOSE] =  dst_mask[(FU_TRANSPOSE)*(`MAX_STAGES-4)+10*(NUM_LANES)-1-:NUM_LANES];
   assign D_wb_last_subvector[FU_TRANSPOSE] = D_last_subvector_s5[FU_TRANSPOSE];
 
   assign wb_dst[((FU_PERMUTE-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((FU_PERMUTE-0)*((REGIDWIDTH-1)-(0)+1))] = permute_dst;
@@ -10252,14 +10309,14 @@
   assign wb_dst_mask[((FU_AXI-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_AXI-0)*((NUMLANES-1)-(0)+1))] = axi_mask;
   assign D_wb_last_subvector[FU_AXI] = D_last_subvector_s5[FU_AXI];
 
-  assign wb_dst[FU_TRP] = dst[FU_TRP][5];
-  assign wb_dst_we[FU_TRP] = dst_we[((FU_TRP-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_TRP-0)*((`MAX_STAGES-1)-(4)+1))] && trp_valid;
-  assign wb_dst_mask[FU_TRP] = dst_mask[FU_TRP][5];
+  assign wb_dst[FU_TRP*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH] = dst[(`MAX_STAGES-4)*(FU_TRP)*REGIDWIDTH+ 2*REGIDWIDTH-1 -:REGIDWIDTH];
+  assign wb_dst_we[FU_TRP] = dst_we[(FU_TRP)*(`MAX_STAGES-4)+1] && trp_valid;
+  assign wb_dst_mask[FU_TRP] =  dst_mask[(FU_TRP)*(`MAX_STAGES-4)+2*(NUM_LANES)-1-:NUM_LANES];
   assign D_wb_last_subvector[FU_TRP] = D_last_subvector_s5[FU_TRP];
 
-  assign wb_dst[FU_MATMUL]=dst[FU_MATMUL][4];
-  assign wb_dst_we[FU_MATMUL]=dst_we[((FU_MATMUL-0)*((`MAX_STAGES-1)-(4)+1)+4-4) : ((FU_MATMUL-0)*((`MAX_STAGES-1)-(4)+1))] && out_data_avail;
-  assign wb_dst_mask[FU_MATMUL]=dst_mask[FU_MATMUL][4];
+  assign wb_dst[FU_MATMUL*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH]=dst[(`MAX_STAGES-4)*(FU_MATMUL)*REGIDWIDTH+ 2*REGIDWIDTH -1-:REGIDWIDTH];
+  assign wb_dst_we[FU_MATMUL]= dst_we[(FU_MATMUL)*(`MAX_STAGES-4)] && out_data_avail;
+  assign wb_dst_mask[FU_MATMUL]= dst_mask[(FU_MATMUL)*(`MAX_STAGES-4)+NUM_LANES-1-:NUM_LANES];
   //TODO: There is no code that assigns to the s31 var used below. Need to add that code
   //This is only a debug var, so it doesn't affect functionality
   assign D_wb_last_subvector[FU_MATMUL]=D_last_subvector_s31[FU_MATMUL];
@@ -10267,7 +10324,8 @@
   // ******************  Map functional units to banks ******************
   always@*
     for (bw=0; bw<NUMBANKS; bw=bw+1)
-    begin
+    begin 
+      //do we want to write or not?
       vr_c_we[bw]=(wb_dst_we[FU_MUL] && `LO(wb_dst[((FU_MUL-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((FU_MUL-0)*((REGIDWIDTH-1)-(0)+1))],LOG2NUMBANKS)==bw) ||
                   (wb_dst_we[FU_MATMUL] && `LO(wb_dst[((FU_MATMUL-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((FU_MATMUL-0)*((REGIDWIDTH-1)-(0)+1))],LOG2NUMBANKS)==bw) ||
                   (wb_dst_we[FU_BFADDER] && `LO(wb_dst[((FU_BFADDER-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((FU_BFADDER-0)*((REGIDWIDTH-1)-(0)+1))],LOG2NUMBANKS)==bw) ||
@@ -10286,12 +10344,14 @@
       //Record if instruction writes to VRF, on last subvector, and not stalled
       D_wb_instrdone[bw] = pipe_advance[5] && (
         ((ALUPERBANK==0) ?
-          (dst_we[((FU_ALU-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_ALU-0)*((`MAX_STAGES-1)-(4)+1))] && D_wb_last_subvector[FU_ALU] && `LO(wb_dst[FU_ALU],LOG2NUMBANKS)==bw) :
-          (dst_we[FU_ALU+bw][5] && D_wb_last_subvector[FU_ALU+bw])) || 
-        (dst_we[((FU_MUL-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_MUL-0)*((`MAX_STAGES-1)-(4)+1))] && D_wb_last_subvector[FU_MUL] && `LO(wb_dst[FU_MUL],LOG2NUMBANKS)==bw) || 
-        (dst_we[((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1)+5-5) : ((FU_MEM-0)*((`MAX_STAGES-1)-(4)+1))] && D_wb_last_subvector[FU_MEM] && `LO(wb_dst[FU_MEM],LOG2NUMBANKS)==bw));
-
-      //Take matmul output
+          (dst_we[(FU_ALU)*(`MAX_STAGES-4)+1] && D_wb_last_subvector[FU_ALU] && `LO(wb_dst[FU_ALU*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH],LOG2NUMBANKS)==bw) :
+          (dst_we[(FU_ALU+bw)*(`MAX_STAGES-4)+1] && D_wb_last_subvector[FU_ALU+bw])) || 
+        (dst_we[(FU_MUL)*(`MAX_STAGES-4)+1] && D_wb_last_subvector[FU_MUL] && `LO(wb_dst[FU_MUL*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH],LOG2NUMBANKS)==bw) || 
+        (dst_we[(FU_MEM)*(`MAX_STAGES-4)+1] && D_wb_last_subvector[FU_MEM] && `LO(wb_dst[FU_MEM*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH],LOG2NUMBANKS)==bw));
+
+      //Take matmul output 
+      //writing the output to the destination 
+      //vr_c_reg has the destination addr, and vr_c_writedatain has the data to be written
       if (wb_dst_we[FU_MATMUL] && `LO(wb_dst[((FU_MATMUL-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((FU_MATMUL-0)*((REGIDWIDTH-1)-(0)+1))],LOG2NUMBANKS)==bw)
       begin
         vmask_final[((bw-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((bw-0)*((NUMLANES-1)-(0)+1))]=wb_dst_mask[((FU_MATMUL-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((FU_MATMUL-0)*((NUMLANES-1)-(0)+1))];
@@ -10385,27 +10445,33 @@
       //Take ALU output
       begin
         vmask_final[((bw-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((bw-0)*((NUMLANES-1)-(0)+1))]=wb_dst_mask[FU_ALU+bw*ALUPERBANK];
-        _vr_c_reg[bw*BANKREGIDWIDTH +: BANKREGIDWIDTH]=wb_dst[FU_ALU+bw*ALUPERBANK]>>LOG2NUMBANKS;
-        vr_c_reg[((bw-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((bw-0)*((REGIDWIDTH-1)-(0)+1))]= wb_dst[FU_ALU+bw*ALUPERBANK];
+        _vr_c_reg[bw*BANKREGIDWIDTH +: BANKREGIDWIDTH]=wb_dst[(FU_ALU+bw*ALUPERBANK)*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH]>>LOG2NUMBANKS;
+        vr_c_reg[((bw-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((bw-0)*((REGIDWIDTH-1)-(0)+1))]= wb_dst[(FU_ALU+bw*ALUPERBANK)*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH];
         vr_c_writedatain[((bw-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((bw-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))]= alu_result_s5[((bw*ALUPERBANK-0)*((LANEWIDTH*NUMLANES-1)-(0)+1)+LANEWIDTH*NUMLANES-1-0) : ((bw*ALUPERBANK-0)*((LANEWIDTH*NUMLANES-1)-(0)+1))];
         //Do ALU and FALU for last subvector
         D_last_subvector_done[bw]=
-          (D_wb_last_subvector[FU_ALU+bw*ALUPERBANK] && `LO(wb_dst[FU_ALU+bw*ALUPERBANK],LOG2NUMBANKS)==bw) |
-          (D_wb_last_subvector[FU_FALU+bw*ALUPERBANK] && `LO(dst[FU_FALU+bw*ALUPERBANK][5],LOG2NUMBANKS)==bw);
+          (D_wb_last_subvector[FU_ALU+bw*ALUPERBANK] && `LO(wb_dst[(FU_ALU+bw*ALUPERBANK)*REGIDWIDTH+REGIDWIDTH-1-:REGIDWIDTH],LOG2NUMBANKS)==bw) |
+
+          (D_wb_last_subvector[FU_FALU+bw*ALUPERBANK] && `LO(dst[(`MAX_STAGES-4)*(FU_FALU+bw*ALUPERBANK)* REGIDWIDTH+2*REGIDWIDTH -1-:REGIDWIDTH],LOG2NUMBANKS)==bw);
+
+                                                               
       end
       for (j=0; j<NUMLANES; j=j+1)
         vr_c_byteen[bw*VPW*NUMLANES + j*VPW +: VPW ]={VPW{vmask_final[((bw-0)*((NUMLANES-1)-(0)+1)+j-j) : ((bw-0)*((NUMLANES-1)-(0)+1))]}};
 
+      //flag register writeback, not really using for now
       //*********** Flag writeback ***********
-      vf_c_reg[bw*BANKREGIDWIDTH+:BANKREGIDWIDTH]=dst[FU_FALU+bw*ALUPERBANK][5]>>LOG2NUMBANKS;
+
+      vf_c_reg[bw*BANKREGIDWIDTH+:BANKREGIDWIDTH]=dst[(`MAX_STAGES-4)*(FU_FALU+bw*ALUPERBANK)*REGIDWIDTH+ 2*REGIDWIDTH -1-:REGIDWIDTH]>>LOG2NUMBANKS;
       vf_c_writedatain[bw*NUMLANES+:NUMLANES]=flagalu_result_s5[((bw*ALUPERBANK-0)*((NUMLANES-1)-(0)+1)+NUMLANES-1-0) : ((bw*ALUPERBANK-0)*((NUMLANES-1)-(0)+1))];
-      vf_c_we[bw]=dst_we[FU_FALU+bw*ALUPERBANK][5] && `LO(dst[FU_FALU+bw*ALUPERBANK][5],LOG2NUMBANKS)==bw;
+      vf_c_we[bw]=dst_we[(FU_FALU+bw*ALUPERBANK)*(`MAX_STAGES-4)+1] && `LO(dst[(FU_FALU+bw*ALUPERBANK)*(`MAX_STAGES-4)+5],LOG2NUMBANKS)==bw;
+      
     end
 
   //********** Scalar writeback ***********
   assign vs_wetrack={ctrl_vs_we[5:4],|ctrl3_vs_we,ctrl2_vs_we};
   assign vs_we=ctrl_vs_we[5] & load_result_mask_s5[0];
-  assign vs_dst=wb_dst[((FU_MEM-0)*((REGIDWIDTH-1)-(0)+1)+REGIDWIDTH-1-0) : ((FU_MEM-0)*((REGIDWIDTH-1)-(0)+1))][`VRID_RANGE];
+  assign vs_dst= wb_dst[(FU_MEM*REGIDWIDTH)+ REGIDWIDTH-1:(FU_MEM*REGIDWIDTH)+REGIDWIDTH-VRIDWIDTH];
   assign vs_writedata=load_result_s5[LANEWIDTH-1:0];
 
 endmodule
@@ -10578,46 +10644,44 @@
 //// Starting contents of included file: visa.v
 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/vector/visa.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/visa.v
 //////////////////////////////////////////////////////////////////////
-parameter COP2_VADD           = 'b10z0000000;
-parameter COP2_VADD_U         = 'b10z0000001;
-parameter COP2_VSUB           = 'b10zz000010;
-parameter COP2_VSUB_U         = 'b10zz000011;
-parameter COP2_VMULHI         = 'b10z0000100;
-parameter COP2_VMULHI_U       = 'b10z0000101;
-parameter COP2_VDIV           = 'b10zz000110; //Using as matmul
+parameter COP2_VADD           = 'b1000000000;
+parameter COP2_VADD_U         = 'b1000000001;
+parameter COP2_VSUB           = 'b1000000010;
+parameter COP2_VSUB_U         = 'b1000000011;
+parameter COP2_VMULHI         = 'b1000000100;
+parameter COP2_VMULHI_U       = 'b1000000101;
+parameter COP2_VDIV           = 'b1000000110; //Using as matmul
 //parameter COP2_VBFADD         = 'b0100000001; //Using BF16 add
 //parameter COP2_VBFMULT        = 'b0100000010; //Using BF16 MULT
 //parameter COP2_VACT           = 'b0100000011; //Using ACT
 //parameter COP2_VTRP           = 'b0100000100; //Using ACT
-parameter COP2_VDIV_U         = 'b10zz000111;
+parameter COP2_VDIV_U         = 'b1000000111;
 
-//parameter COP2_VMOD           = 'b10zz001000;
-parameter COP2_VBFADD           = 'b10zz001000;  // USING bfloat add Instr: vmod.vv vrdest, vrsrc1,vrsrc2
+//parameter COP2_VMOD           = 'b1000001000;
+parameter COP2_VBFADD           = 'b1000001000;  // USING bfloat add Instr: vmod.vv vrdest, vrsrc1,vrsrc2
 
-//parameter COP2_VMOD_U         = 'b10zz001001;
-parameter COP2_VBFMULT         = 'b10zz001001;  // Using bfloat mult Instr: vmod.u.vv vrdest, vrsrc1,vrsrc2
-parameter COP2_VMOD_U         = 'b10zz001001;
-parameter COP2_VCMP_EQ        = 'b10zz001010;
-parameter COP2_VCMP_NE        = 'b10zz001100;
-parameter COP2_VCMP_LT        = 'b10zz001110;
-parameter COP2_VCMP_U_LT      = 'b10zz001111;
-parameter COP2_VCMP_LE        = 'b10zz010000;
-parameter COP2_VCMP_U_LE      = 'b10zz010001;
-parameter COP2_VMIN           = 'b10z0010010;
-parameter COP2_VMIN_U         = 'b10z0010011;
-parameter COP2_VMAX           = 'b10z0010100;
-parameter COP2_VMAX_U         = 'b10z0010101;
-parameter COP2_VMULLO         = 'b10z0010110;
+parameter COP2_VMOD_U         = 'b1000001001;
+parameter COP2_VCMP_EQ        = 'b1000001010;
+parameter COP2_VCMP_NE        = 'b1000001100;
+parameter COP2_VCMP_LT        = 'b1000001110;
+parameter COP2_VCMP_U_LT      = 'b1000001111;
+parameter COP2_VCMP_LE        = 'b1000010000;
+parameter COP2_VCMP_U_LE      = 'b1000010001;
+parameter COP2_VMIN           = 'b1000010010;
+parameter COP2_VMIN_U         = 'b1000010011;
+parameter COP2_VMAX           = 'b1000010100;
+parameter COP2_VMAX_U         = 'b1000010101;
+parameter COP2_VMULLO         = 'b1000010110;
 parameter COP2_VABS           = 'b1000010111;
-parameter COP2_VAND           = 'b10z0011000;
-parameter COP2_VOR            = 'b10z0011001;
-parameter COP2_VXOR           = 'b10z0011010;
-parameter COP2_VNOR           = 'b10z0011011;
-parameter COP2_VSLL           = 'b10zz011100;
-parameter COP2_VSRL           = 'b10zz011101;
-parameter COP2_VSRA           = 'b10zz011110;
+parameter COP2_VAND           = 'b1000011000;
+parameter COP2_VOR            = 'b1000011001;
+parameter COP2_VXOR           = 'b1000011010;
+parameter COP2_VNOR           = 'b1000011011;
+parameter COP2_VSLL           = 'b1000011100;
+parameter COP2_VSRL           = 'b1000011101;
+parameter COP2_VSRA           = 'b1000011110;
 parameter COP2_VSAT_B         = 'b1000011111;
 parameter COP2_VSAT_H         = 'b1001011111;
 //parameter COP2_VSAT_W         = 'b1010011111;
@@ -10631,26 +10695,26 @@
 parameter COP2_VSAT_U_H       = 'b1001100001;
 //parameter COP2_VSAT_U_W       = 'b1010100001;
 parameter COP2_VTRP       = 'b1010100001;   // Using transpose instruction: vsat.u.w vrdest, vrsrc 
-parameter COP2_VSADD          = 'b10z0100010;
-parameter COP2_VSADD_U        = 'b10z0100011;
-parameter COP2_VSSUB          = 'b10zz100100;
-parameter COP2_VSSUB_U        = 'b10zz100101;
+parameter COP2_VSADD          = 'b1000100010;
+parameter COP2_VSADD_U        = 'b1000100011;
+parameter COP2_VSSUB          = 'b1000100100;
+parameter COP2_VSSUB_U        = 'b1000100101;
 parameter COP2_VSRR           = 'b1000100110;
 parameter COP2_VSRR_U         = 'b1000100111;
 parameter COP2_VSLS           = 'b1000101000;
 parameter COP2_VSLS_U         = 'b1000101001;
-parameter COP2_VXUMUL         = 'b10z0101010;
-parameter COP2_VXUMUL_U       = 'b10z0101011;
-parameter COP2_VXLMUL         = 'b10z0101100;
-parameter COP2_VXLMUL_U       = 'b10z0101101;
-parameter COP2_VXUMADD        = 'b10z0101110;
-parameter COP2_VXUMADD_U      = 'b10z0101111;
-parameter COP2_VXUMSUB        = 'b10z0110000;
-parameter COP2_VXUMSUB_U      = 'b10z0110001;
-parameter COP2_VXLMADD        = 'b10z0110010;
-parameter COP2_VXLMADD_U      = 'b10z0110011;
-parameter COP2_VXLMSUB        = 'b10z0110100;
-parameter COP2_VXLMSUB_U      = 'b10z0110101;
+parameter COP2_VXUMUL         = 'b1000101010;
+parameter COP2_VXUMUL_U       = 'b1000101011;
+parameter COP2_VXLMUL         = 'b1000101100;
+parameter COP2_VXLMUL_U       = 'b1000101101;
+parameter COP2_VXUMADD        = 'b1000101110;
+parameter COP2_VXUMADD_U      = 'b1000101111;
+parameter COP2_VXUMSUB        = 'b1000110000;
+parameter COP2_VXUMSUB_U      = 'b1000110001;
+parameter COP2_VXLMADD        = 'b1000110010;
+parameter COP2_VXLMADD_U      = 'b1000110011;
+parameter COP2_VXLMSUB        = 'b1000110100;
+parameter COP2_VXLMSUB_U      = 'b1000110101;
 parameter COP2_VINS_VV        = 'b1100000000;
 parameter COP2_VINS_SV        = 'b1110000001;
 parameter COP2_VEXT_VV        = 'b1100000010;
@@ -10658,17 +10722,17 @@
 parameter COP2_VEXT_U_SV      = 'b1100000100;
 parameter COP2_VCOMPRESS      = 'b1100000101;
 parameter COP2_VEXPAND        = 'b1100000110;
-parameter COP2_VMERGE         = 'b11zz000111;
+parameter COP2_VMERGE         = 'b1100000111;
 parameter COP2_VFINS          = 'b1110001000;
 parameter COP2_VEXTHALF       = 'b1100001001;
 parameter COP2_VHALF          = 'b1100001010;
 parameter COP2_VHALFUP        = 'b1100001011;
 parameter COP2_VHALFDN        = 'b1100001100;
 parameter COP2_VSATVL         = 'b1100001101;
-parameter COP2_VFAND          = 'b11z0001110;
-parameter COP2_VFOR           = 'b11z0001111;
-parameter COP2_VFXOR          = 'b11z0010000;
-parameter COP2_VFNOR          = 'b11z0010001;
+parameter COP2_VFAND          = 'b1100001110;
+parameter COP2_VFOR           = 'b1100001111;
+parameter COP2_VFXOR          = 'b1100010000;
+parameter COP2_VFNOR          = 'b1100010001;
 parameter COP2_VFCLR          = 'b1100010010;
 parameter COP2_VFSET          = 'b1100010011;
 parameter COP2_VIOTA          = 'b1100010100;
@@ -10708,7 +10772,7 @@
 parameter COP2_VLDS_U_H       = 'b1101100100;
 
 //parameter COP2_VLDS_U_W       = 'b1110100100;
-//parameter COP2_VBFMULT         = 'b1110100100;   // adding bfmult Instr: vlds.u.w
+parameter COP2_VBFMULT         = 'b1110100100;   // adding bfmult Instr: vlds.u.w
 
 parameter COP2_VLDX_B         = 'b1100100101;
 parameter COP2_VLDX_H         = 'b1101100101;
@@ -10828,7 +10892,7 @@
 output  [3 : 0]                      M_ARQOS;                                                  
 output                               M_ARVALID;                                                        
 input                                M_ARREADY;                                                        
-input   [6-1 : 0]                    M_RID;                                         	    
+input   [6-1 : 0]                    M_RID;                                                 
 input   [NUMLANES*LANEWIDTH-1 : 0]   M_RDATA;                                     
 input   [1 : 0]                      M_RRESP;                                                  
 input                                M_RLAST;                                                          
@@ -10868,7 +10932,7 @@
 input  [3 : 0]                      S_ARQOS;                                                  
 input                               S_ARVALID;                                                        
 output                                S_ARREADY;                                                        
-output   [6-1 : 0]                    S_RID;                                         	    
+output   [6-1 : 0]                    S_RID;                                                
 output   [NUMLANES*LANEWIDTH-1 : 0]   S_RDATA;                                     
 output   [1 : 0]                      S_RRESP;                                                  
 output                                S_RLAST;                                                          
@@ -12130,14 +12194,14 @@
     .dbus_wait(dbus_wait),
 
     //DMA interface
-    .dma_dbus_address	(dma_dbus_address), 
-    .dma_dbus_readdata	(dma_dbus_readdata), 
-    .dma_dbus_writedata	(dma_dbus_writedata),
-    .dma_dbus_byteen	(dma_dbus_byteen),
-    .dma_dbus_en	(dma_dbus_en),       
-    .dma_dbus_wren	(dma_dbus_wren),     
-    .dma_dbus_prefetch	(dma_dbus_prefetch), 
-    .dma_dbus_wait	(dma_dbus_wait),     
+    .dma_dbus_address   (dma_dbus_address), 
+    .dma_dbus_readdata  (dma_dbus_readdata), 
+    .dma_dbus_writedata (dma_dbus_writedata),
+    .dma_dbus_byteen    (dma_dbus_byteen),
+    .dma_dbus_en    (dma_dbus_en),       
+    .dma_dbus_wren  (dma_dbus_wren),     
+    .dma_dbus_prefetch  (dma_dbus_prefetch), 
+    .dma_dbus_wait  (dma_dbus_wait),     
     .dma_dbus_data_valid(dma_dbus_data_valid)
     );
   defparam 
@@ -12166,8 +12230,9 @@
 
 endmodule
 
+/*
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/local/spram1.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/local/spram1.v
 //////////////////////////////////////////////////////////////////////
 module spram1 (
     clk,
@@ -12194,7 +12259,7 @@
 integer i;
 integer k;
 
-reg [(((67108864-1)-(0)+1)*((32-1)-(0)+1))-1 : 0] ram;
+reg [32-1:0] ram[67108864-1:0];
 //reg [32-1:0] ram[4096-1:0];
 reg [25:0] addr;
  
@@ -12228,18 +12293,18 @@
 
 /*
 //single_port_ram u_single_port_ram(
-.addr(address),
-.we(wren),
-.data(data),
-.out(out),
-.clk(clk)
-);
+//.addr(address),
+//.we(wren),
+//.data(data),
+//.out(out),
+//.clk(clk)
+//);
+//`endif
 
-`endif
-*/
 endmodule
+*/
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/local/rams.v
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/local/rams.v
 //////////////////////////////////////////////////////////////////////
 module dpram (
 	clk,
@@ -12354,9 +12419,8 @@
 
 `endif
 
-endmodule
-//////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/local/local_add_sub.v
+endmodule//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/local/local_add_sub.v
 //////////////////////////////////////////////////////////////////////
 module local_add_sub(
 dataa,
@@ -12383,9 +12447,8 @@
          result = dataa - datab;
 end
 
-endmodule
-//////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/local/local_mult.v
+endmodule//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/local/local_mult.v
 //////////////////////////////////////////////////////////////////////
 module local_mult(
 dataa,
@@ -12438,9 +12501,8 @@
        result <= unsignedoutputP; 
 end
 
-endmodule
-//////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/local/local_fifo.v
+endmodule//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/local/local_fifo.v
 //////////////////////////////////////////////////////////////////////
 module fifo#(
 parameter FIFO_WIDTH = 8,
@@ -12523,10 +12585,8 @@
  end
 end
 
-endmodule
-
-//////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/local/local_shifter.v
+endmodule//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/local/local_shifter.v
 //////////////////////////////////////////////////////////////////////
 module local_shifter(
   data,
@@ -12577,33 +12637,190 @@
             end
   endcase
 end
-endmodule
+endmodule//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/top/options.v
 //////////////////////////////////////////////////////////////////////
-//// Starting contents of file: /mnt/f/ceremorphic/lizy/latest/tpu_v2-main/tpu/design/scalar/components.v
+`ifndef _OPTIONS_V_
+`define _OPTIONS_V_ 1
+
+`define NO_PLI 1
+//`define TEST_BENCH 1
+`define USE_INHOUSE_LOGIC
+//`define SIMULATION_MEMORY
+// Replaces altera blocks with local logic files
+
+/************************** ABBREVIEATED NAMES *****************************/
+// Note: LG = Log base 2
+//
+// Default configuration:
+//    8KB Icache (LGID=13) with 16 byte cache line size (LGIW=4)
+//   32KB Dcache (LGDD=15) with 64 byte cache line size (LGDD=6)
+//    Data prefetching off (DP=0, DPV=0)
+//    16 Vector Lanes (LGL=4)
+//    64 Maximum Vector Length (LGMVL=6)
+//    32-bit (4-byte) Vector lane width (LGVPW=2)
+//    32-bit Vector lane datapath width (LGLW=5)
+//    16 Memory Crossbar lanes (LGM=LGL)
+//    16 Multiplier lanes (LGX=LGL)
+//    2 Register Banks (LGB=1)
+//    Disable ALU per Bank (APB=0)
+
+
+// INSTR CACHE
+`define LGID 13
+`define LGIW 4
+
+// DATA CACHE
+`define LGDD 15
+`define LGDW 4
+
+// DATA CACHE PREFETCHER - dcache needs to have 64 byte lines
+`define LGDWB 7
+`define DP 0
+// VECTOR DATA CACHE PREFETCHER 0:off, 65535-N:N*veclength, N:pfch N cache lines
+`define DPV 0
+
+// VECTOR CORE
+//Changing to 3. That is, we now have 8 lanes.
+`define LGL 3
+`define LGB 0
+`define APB 0
+`define LGM `LGL
+`define LGX `LGL
+
+// VECTOR ISA
+`define LGMVL 6
+`define LGVPW 1 //chaging the word size of vector processor to 16: support for bfloat16
+`define LGLW 4
+
+/****************************** FULL NAMES *********************************/
+
+// INSTR CACHE
+`define LOG2ICACHEDEPTHBYTES `LGID
+`define LOG2ICACHEWIDTHBITS (`LGIW+3)
+
+// DATA CACHE
+`define LOG2DCACHEDEPTHBYTES `LGDD
+`define LOG2DCACHEWIDTHBITS (`LGDW+3)
+
+// DATA CACHE PREFETCHER - dcache needs to have 64 byte lines
+`define LOG2DATAWBBUFFERSIZE `LGDWB
+`define DEFAULTDCACHEPREFETCHES `DP
+// VECTOR DATA CACHE PREFETCHER 0:off, 65535:vectorlength, N:pfch N cache lines
+`define VECTORPREFETCHES `DPV
+
+// VECTOR CORE
+`define LOG2NUMLANES `LGL
+`define LOG2MVL `LGMVL
+`define LOG2VPW `LGVPW
+`define LOG2LANEWIDTHBITS `LGLW
+`define LOG2NUMMEMLANES `LGM
+`define LOG2NUMMULLANES `LGX
+`define LOG2NUMBANKS `LGB
+`define ALUPERBANK `APB
+
+`define MAX_STAGES 14
+/****************************** OTHER PARAMS *********************************/
+
+// DRAM
+`define LOG2DRAMWIDTHBITS 7
+
+/****************** NUM PIPELINE STAGES in VECTOR PROCESSOR ***************/
+//mult consumes 3 cycles
+//`define MAX_PIPE_STAGES 7
+//matmul consumes 29 cycles
+`define MAX_PIPE_STAGES 8
+`define MATMUL_STAGES 29
+
+/****************** SIZE OF THE MATMUL UNIT ***************/
+`define MAT_MUL_SIZE 8
+
+`endif
 //////////////////////////////////////////////////////////////////////
-/****************************************************************************
-          Generic Register
-****************************************************************************/
-module register(d,clk,resetn,en,q);
-parameter WIDTH=32;
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/scalar/ram_wrapper.v
+//////////////////////////////////////////////////////////////////////
+module ram_wrapper (
+  clk,
+        resetn,
+  address_a,
+  address_b,
+        rden_a,
+        rden_b,
+  wren_a,
+  wren_b,
+  data_a,
+  data_b,
+  out_a,
+  out_b
+);
+
+parameter AWIDTH=10;
+parameter NUM_WORDS=1024;
+parameter DWIDTH=32;
 
 input clk;
 input resetn;
-input en;
-input [WIDTH-1:0] d;
-output [WIDTH-1:0] q;
-reg [WIDTH-1:0] q;
+input [(AWIDTH-1):0] address_a;
+input [(AWIDTH-1):0] address_b;
+input  wren_a;
+input  wren_b;
+input  rden_a;
+input  rden_b;
+input [(DWIDTH-1):0] data_a;
+input [(DWIDTH-1):0] data_b;
+output [(DWIDTH-1):0] out_a;
+output [(DWIDTH-1):0] out_b;
 
-always @(posedge clk or negedge resetn)		//asynchronous reset
-begin
-	if (resetn==0)
-		q<=0;
-	else if (en==1)
-		q<=d;
+reg [(AWIDTH-1):0] q_address_a;
+reg [(AWIDTH-1):0] q_address_b;
+reg [(AWIDTH-1):0] mux_address_b;
+
+dpram dpram1(
+    .clk(clk),
+    .address_a(address_a),
+    .address_b(mux_address_b),
+    .wren_a(wren_a),
+    .wren_b(wren_b),
+    .data_a(data_a),
+    .data_b(data_b),
+    .out_a(out_a),
+    .out_b(out_b)
+);
+defparam
+    dpram1.AWIDTH=AWIDTH,
+    dpram1.NUM_WORDS=NUM_WORDS,
+    dpram1.DWIDTH=DWIDTH;
+
+always@(posedge clk)begin
+   if(!resetn)begin
+     q_address_a <= 'h0;
+     q_address_b <= 'h0;
+   end
+   else begin
+     if(rden_b)
+       q_address_b <= address_b;
+   end
+end
+
+always@(*)begin
+  if(rden_b)   
+    mux_address_b = address_b;
+  else
+    mux_address_b = q_address_b; 
 end
 
 endmodule
 
+
+//////////////////////////////////////////////////////////////////////
+//// Ending contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/scalar/ram_wrapper.v
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/scalar/components.v
+//////////////////////////////////////////////////////////////////////
+
+
 /****************************************************************************
           Generic Register - synchronous reset
 ****************************************************************************/
@@ -12617,12 +12834,12 @@
 output [WIDTH-1:0] q;
 reg [WIDTH-1:0] q;
 
-always @(posedge clk)		//synchronous reset
+always @(posedge clk)   //synchronous reset
 begin
-	if (resetn==0)
-		q<=0;
-	else if (en==1)
-		q<=d;
+  if (resetn==0)
+    q<=0;
+  else if (en==1)
+    q<=d;
 end
 
 endmodule
@@ -12689,56 +12906,7 @@
 endmodule
 ****************************************************************************/
 
-/****************************************************************************
-          One cycle Stall circuit
-****************************************************************************/
-module onecyclestall(request,clk,resetn,stalled);
-input request;
-input clk;
-input resetn;
-output stalled;
-
-  reg T,Tnext;
-
-  // State machine for Stalling 1 cycle
-  always@(request or T)
-  begin
-    case(T) 
-      1'b0: Tnext=request;
-      1'b1: Tnext=0;
-    endcase 
-  end       
-  always@(posedge clk)
-    if (~resetn)
-      T<=0; 
-    else    
-      T<=Tnext;
-  assign stalled=(request&~T);
-endmodule
-
-/****************************************************************************
-          Multi cycle Stall circuit - with wait signal
-
-          - One FF plus one 2:1 mux to stall 1st cycle on request, then wait
-          - this makes wait don't care for the first cycle
-****************************************************************************/
-module multicyclestall(request, devwait,clk,resetn,stalled);
-input request;
-input devwait;
-input clk;
-input resetn;
-output stalled;
-
-  reg T;
 
-  always@(posedge clk)
-    if (~resetn)
-      T<=0;
-    else
-      T<=stalled;
-
-  assign stalled=(T) ? devwait : request;
-endmodule
                 
 /****************************************************************************
           One cycle - Pipeline delay register
@@ -12850,3 +13018,3431 @@
                   ((is_special)&&(func[5:3]==3'b001));
 
 endmodule
+
+//////////////////////////////////////////////////////////////////////
+//// Ending contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/scalar/components.v
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/activation.v
+//////////////////////////////////////////////////////////////////////
+module activation #(parameter WIDTH = 4)(
+ input clk,
+ input resetn,
+ input en,
+ input stall,
+ input [WIDTH-1:0] a,
+ output reg[WIDTH-1:0] out
+);
+
+always@(posedge clk)begin
+  if(!resetn)
+    out <= 'h0;
+  else
+    if(en)
+      if(a[WIDTH-1] == 1'b0)
+        out <= a;
+      else
+        out <= 0;
+end
+
+endmodule
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/activation.v
+//////////////////////////////////////////////////////////////////////
+
+
+
+//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/FPAddSub.v
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////////////////
+//
+// Create Date:    01:56:20 09/07/2012 
+// Module Name:    FPAddSub
+// Project Name:   Floating Point Project
+// Author:       Fredrik Brosser
+//
+// Description:  Top Module for a 32-bit floating point adder/subtractor.
+//             Follows the IEEE754 Single Precision standard.
+//             Supports only the default rounding mode.
+//
+//  Inputs:
+//        a (32 bits)     : Single precision IEEE754 floating point number
+//        b (32 bits)     : Single precision IEEE754 floating point number
+//        operation (1 bit) : Single control bit. 0/Addition, 1/Subtraction
+//
+//
+// Outputs:
+//        result (32 bits)  : Result of the operation, in IEEE754 Single format
+//        flags  (5 bits) : Flags indicating exceptions:
+//                      Bit 4: Overflow
+//                      Bit 3: Underflow
+//                      Bit 2: Divide by Zero
+//                      Bit 1: Invalid/NaN
+//                      Bit 0: Inexact
+//
+//////////////////////////////////////////////////////////////////////////////////
+`define EXPONENT 5
+`define MANTISSA 10
+`define ACTUAL_MANTISSA 11
+`define EXPONENT_LSB 10
+`define EXPONENT_MSB 14
+`define MANTISSA_LSB 0
+`define MANTISSA_MSB 9
+`define MANTISSA_MUL_SPLIT_LSB 3
+`define MANTISSA_MUL_SPLIT_MSB 9
+`define SIGN 1
+`define SIGN_LOC 15
+`define DWIDTH (`SIGN+`EXPONENT+`MANTISSA)
+`define IEEE_COMPLIANCE 1
+
+module FPAddSub(
+    clk,
+    rst,
+                en,
+    a,
+    b,
+    operation,      // 0 add, 1 sub
+    result,
+                valid,
+    flags
+  );
+  
+  // Clock and reset
+  input clk ;                   // Clock signal
+  input rst ;                   // Reset (active high, resets pipeline registers)
+  
+  // Input ports
+  input en ;
+  input [`DWIDTH-1:0] a ;               // Input A, a 32-bit floating point number
+  input [`DWIDTH-1:0] b ;               // Input B, a 32-bit floating point number
+  input operation ;               // Operation select signal
+  
+  // Output ports
+  output valid;
+  output [`DWIDTH-1:0] result ;           // Result of the operation
+  output [4:0] flags ;              // Flags indicating exceptions according to IEEE754
+  
+  // Pipeline Registers
+  //reg [79:0] pipe_1;              // Pipeline register PreAlign->Align1
+  reg [`DWIDTH*2+15:0] pipe_1;              // Pipeline register PreAlign->Align1
+        wire[`DWIDTH*2+15:0] stage_0_1;
+
+  //reg [67:0] pipe_2;              // Pipeline register Align1->Align3
+  reg [`MANTISSA*2+`EXPONENT+13:0] pipe_2;              // Pipeline register Align1->Align3
+        wire[`MANTISSA*2+`EXPONENT+13:0] stage_1_2;
+
+  //reg [76:0] pipe_3;  68            // Pipeline register Align1->Align3
+  reg [`MANTISSA*2+`EXPONENT+14:0] pipe_3;              // Pipeline register Align1->Align3
+
+  //reg [69:0] pipe_4;              // Pipeline register Align3->Execute
+  reg [`MANTISSA*2+`EXPONENT+15:0] pipe_4;              // Pipeline register Align3->Execute
+        wire[`MANTISSA*2+`EXPONENT+15:0] stage_3_4;
+
+  //reg [51:0] pipe_5;              // Pipeline register Execute->Normalize
+  reg [`DWIDTH+`EXPONENT+11:0] pipe_5;              // Pipeline register Execute->Normalize
+        wire[`DWIDTH+`EXPONENT+11:0] stage_4_5;
+
+  //reg [56:0] pipe_6;              // Pipeline register Nomalize->NormalizeShift1
+  reg [`DWIDTH+`EXPONENT+16:0] pipe_6;              // Pipeline register Nomalize->NormalizeShift1
+
+  //reg [56:0] pipe_7;              // Pipeline register NormalizeShift2->NormalizeShift3
+  reg [`DWIDTH+`EXPONENT+16:0] pipe_7;              // Pipeline register NormalizeShift2->NormalizeShift3
+        wire[`DWIDTH+`EXPONENT+16:0] stage_6_7;
+
+  //reg [54:0] pipe_8;              // Pipeline register NormalizeShift3->Round
+  reg [`EXPONENT*2+`MANTISSA+15:0] pipe_8;              // Pipeline register NormalizeShift3->Round
+        wire[`EXPONENT*2+`MANTISSA+15:0] stage_7_8;
+
+  //reg [40:0] pipe_9;              // Pipeline register NormalizeShift3->Round
+  reg [`DWIDTH+8:0] pipe_9;             // Pipeline register NormalizeShift3->Round
+  
+  // Internal wires between modules
+  wire [`DWIDTH-2:0] Aout_0 ;             // A - sign
+  wire [`DWIDTH-2:0] Bout_0 ;             // B - sign
+  wire Opout_0 ;                  // A's sign
+  wire Sa_0 ;                   // A's sign
+  wire Sb_0 ;                   // B's sign
+  wire MaxAB_1 ;                  // Indicates the larger of A and B(0/A, 1/B)
+  wire [`EXPONENT-1:0] CExp_1 ;             // Common Exponent
+  wire [4:0] Shift_1 ;              // Number of steps to smaller mantissa shift right (align)
+  wire [`MANTISSA-1:0] Mmax_1 ;             // Larger mantissa
+  wire [4:0] InputExc_0 ;           // Input numbers are exceptions
+  wire [9:0] ShiftDet_0 ;
+  wire [`MANTISSA-1:0] MminS_1 ;            // Smaller mantissa after 0/16 shift
+  wire [`MANTISSA:0] MminS_2 ;            // Smaller mantissa after 0/4/8/12 shift
+  wire [`MANTISSA:0] Mmin_3 ;             // Smaller mantissa after 0/1/2/3 shift
+  wire [`DWIDTH:0] Sum_4 ;
+  wire PSgn_4 ;
+  wire Opr_4 ;
+  wire [4:0] Shift_5 ;              // Number of steps to shift sum left (normalize)
+  wire [`DWIDTH:0] SumS_5 ;             // Sum after 0/16 shift
+  wire [`DWIDTH:0] SumS_6 ;             // Sum after 0/16 shift
+  wire [`DWIDTH:0] SumS_7 ;             // Sum after 0/16 shift
+  wire [`MANTISSA-1:0] NormM_8 ;            // Normalized mantissa
+  wire [`EXPONENT:0] NormE_8;             // Adjusted exponent
+  wire ZeroSum_8 ;                // Zero flag
+  wire NegE_8 ;                 // Flag indicating negative exponent
+  wire R_8 ;                    // Round bit
+  wire S_8 ;                    // Final sticky bit
+  wire FG_8 ;                   // Final sticky bit
+  wire [`DWIDTH-1:0] P_int ;
+  wire EOF ;
+        reg q1_valid;
+        reg q2_valid;
+        reg q3_valid;
+        
+  assign valid = q3_valid;
+  // Prepare the operands for alignment and check for exceptions
+  FPAddSub_PrealignModule PrealignModule
+  ( // Inputs
+    a, b, operation,
+    // Outputs
+    Sa_0, Sb_0, ShiftDet_0[9:0], InputExc_0[4:0], Aout_0[`DWIDTH-2:0], Bout_0[`DWIDTH-2:0], Opout_0) ;
+  
+        assign stage_0_1 = {Opout_0, Aout_0[`DWIDTH-2:0], Bout_0[`DWIDTH-2:0], Sa_0, Sb_0, ShiftDet_0[9:0], InputExc_0[4:0]};
+  
+  // Prepare the operands for alignment and check for exceptions
+  FPAddSub_AlignModule AlignModule
+  ( // Inputs
+    //pipe_1[14+2*`DWIDTH:16+`DWIDTH], pipe_1[15+`DWIDTH:17], pipe_1[14:5],
+    stage_0_1[14+2*`DWIDTH:16+`DWIDTH], stage_0_1[15+`DWIDTH:17], stage_0_1[14:5],
+    // Outputs
+    CExp_1[`EXPONENT-1:0], MaxAB_1, Shift_1[4:0], MminS_1[`MANTISSA-1:0], Mmax_1[`MANTISSA-1:0]) ;  
+
+        assign stage_1_2 = {stage_0_1[`DWIDTH*2+15], stage_0_1[16:15], MaxAB_1, CExp_1[`EXPONENT-1:0], Shift_1[4:0], Mmax_1[`MANTISSA-1:0], stage_0_1[4:0], MminS_1[`MANTISSA-1:0]};
+          
+  // Alignment Shift Stage 1
+  FPAddSub_AlignShift1 AlignShift1
+  (  // Inputs
+    stage_1_2[`MANTISSA-1:0], stage_1_2[2*`MANTISSA+9:2*`MANTISSA+7],
+    // Outputs
+    MminS_2[`MANTISSA:0]) ;
+
+  // Alignment Shift Stage 3 and compution of guard and sticky bits
+  FPAddSub_AlignShift2 AlignShift2  
+  (  // Inputs
+    pipe_3[`MANTISSA:0], pipe_3[2*`MANTISSA+7:2*`MANTISSA+6],
+    // Outputs
+    Mmin_3[`MANTISSA:0]) ;
+            
+        assign stage_3_4 = {pipe_3[`MANTISSA*2+`EXPONENT+14:`MANTISSA+1], Mmin_3[`MANTISSA:0]};
+  // Perform mantissa addition
+  FPAddSub_ExecutionModule ExecutionModule
+  (  // Inputs
+    stage_3_4[`MANTISSA*2+5:`MANTISSA+6], stage_3_4[`MANTISSA:0], stage_3_4[`MANTISSA*2+`EXPONENT+13], stage_3_4[`MANTISSA*2+`EXPONENT+12], stage_3_4[`MANTISSA*2+`EXPONENT+11], stage_3_4[`MANTISSA*2+`EXPONENT+14],
+    // Outputs
+    Sum_4[`DWIDTH:0], PSgn_4, Opr_4) ;
+        assign stage_4_5 = {stage_3_4[2*`MANTISSA+`EXPONENT+14], PSgn_4, Opr_4, stage_3_4[2*`MANTISSA+`EXPONENT+13:2*`MANTISSA+11], stage_3_4[`MANTISSA+5:`MANTISSA+1], Sum_4[`DWIDTH:0]};
+  
+  // Prepare normalization of result
+  FPAddSub_NormalizeModule NormalizeModule
+  (  // Inputs
+    stage_4_5[`DWIDTH:0], 
+    // Outputs
+    SumS_5[`DWIDTH:0], Shift_5[4:0]) ;
+          
+  // Normalization Shift Stage 1
+  FPAddSub_NormalizeShift1 NormalizeShift1
+  (  // Inputs
+    pipe_6[`DWIDTH:0], pipe_6[`DWIDTH+`EXPONENT+14:`DWIDTH+`EXPONENT+11],
+    // Outputs
+    SumS_7[`DWIDTH:0]) ;
+        
+        assign stage_6_7 = {pipe_6[`DWIDTH+`EXPONENT+16:`DWIDTH+1], SumS_7[`DWIDTH:0]};
+    
+  // Normalization Shift Stage 3 and final guard, sticky and round bits
+  FPAddSub_NormalizeShift2 NormalizeShift2
+  (  // Inputs
+    stage_6_7[`DWIDTH:0], stage_6_7[`DWIDTH+`EXPONENT+5:`DWIDTH+6], stage_6_7[`DWIDTH+`EXPONENT+15:`DWIDTH+`EXPONENT+11],
+    // Outputs
+    NormM_8[`MANTISSA-1:0], NormE_8[`EXPONENT:0], ZeroSum_8, NegE_8, R_8, S_8, FG_8) ;
+       
+        assign stage_7_8 = {FG_8, stage_6_7[`DWIDTH+`EXPONENT+16], stage_6_7[`DWIDTH+`EXPONENT+10], stage_6_7[`DWIDTH+`EXPONENT+8:`DWIDTH+1], NormM_8[`MANTISSA-1:0], NormE_8[`EXPONENT:0], ZeroSum_8, NegE_8, R_8, S_8};
+
+  // Round and put result together
+  FPAddSub_RoundModule RoundModule
+  (  // Inputs
+     stage_7_8[3], stage_7_8[4+`EXPONENT:4], stage_7_8[`EXPONENT+`MANTISSA+4:5+`EXPONENT], stage_7_8[1], stage_7_8[0], stage_7_8[`EXPONENT*2+`MANTISSA+15], stage_7_8[`EXPONENT*2+`MANTISSA+12], stage_7_8[`EXPONENT*2+`MANTISSA+11], stage_7_8[`EXPONENT*2+`MANTISSA+14], stage_7_8[`EXPONENT*2+`MANTISSA+10], 
+    // Outputs
+    P_int[`DWIDTH-1:0], EOF) ;
+  
+  // Check for exceptions
+  FPAddSub_ExceptionModule Exceptionmodule
+  (  // Inputs
+    pipe_9[8+`DWIDTH:9], pipe_9[8], pipe_9[7], pipe_9[6], pipe_9[5:1], pipe_9[0], 
+    // Outputs
+    result[`DWIDTH-1:0], flags[4:0]) ;      
+  
+  always @ (posedge clk) begin  
+    if(rst) begin
+      //pipe_1 = 0;
+      //pipe_2 = 0;
+      pipe_3 = 0;
+      //pipe_4 = 0;
+      //pipe_5 = 0;
+      pipe_6 = 0;
+      //pipe_7 = 0;
+      //pipe_8 = 0;
+      pipe_9 = 0;
+    end 
+    else begin
+    
+      //pipe_1 = {Opout_0, Aout_0[`DWIDTH-2:0], Bout_0[`DWIDTH-2:0], Sa_0, Sb_0, ShiftDet_0[9:0], InputExc_0[4:0]} ;  
+      /* PIPE_2 :
+        [67] operation
+        [66] Sa_0
+        [65] Sb_0
+        [64] MaxAB_0
+        [63:56] CExp_0
+        [55:51] Shift_0
+        [50:28] Mmax_0
+        [27:23] InputExc_0
+        [22:0] MminS_1
+      */
+      //pipe_2 = {pipe_1[`DWIDTH*2+15], pipe_1[16:15], MaxAB_1, CExp_1[`EXPONENT-1:0], Shift_1[4:0], Mmax_1[`MANTISSA-1:0], pipe_1[4:0], MminS_1[`MANTISSA-1:0]} ;  
+      /* PIPE_3 :
+        [68] operation
+        [67] Sa_0
+        [66] Sb_0
+        [65] MaxAB_0
+        [64:57] CExp_0
+        [56:52] Shift_0
+        [51:29] Mmax_0
+        [28:24] InputExc_0
+        [23:0] MminS_1
+      */
+      pipe_3 = {stage_1_2[`MANTISSA*2+`EXPONENT+13:`MANTISSA], MminS_2[`MANTISSA:0]} ;  
+      /* PIPE_4 :
+        [68] operation
+        [67] Sa_0
+        [66] Sb_0
+        [65] MaxAB_0
+        [64:57] CExp_0
+        [56:52] Shift_0
+        [51:29] Mmax_0
+        [28:24] InputExc_0
+        [23:0] Mmin_3
+      */          
+      //pipe_4 = {pipe_3[`MANTISSA*2+`EXPONENT+14:`MANTISSA+1], Mmin_3[`MANTISSA:0]} ;  
+      /* PIPE_5 :
+        [51] operation
+        [50] PSgn_4
+        [49] Opr_4
+        [48] Sa_0
+        [47] Sb_0
+        [46] MaxAB_0
+        [45:38] CExp_0
+        [37:33] InputExc_0
+        [32:0] Sum_4
+      */          
+      //pipe_5 = {pipe_4[2*`MANTISSA+`EXPONENT+14], PSgn_4, Opr_4, pipe_4[2*`MANTISSA+`EXPONENT+13:2*`MANTISSA+11], pipe_4[`MANTISSA+5:`MANTISSA+1], Sum_4[`DWIDTH:0]} ;
+      /* PIPE_6 :
+        [56] operation
+        [55:51] Shift_5
+        [50] PSgn_4
+        [49] Opr_4
+        [48] Sa_0
+        [47] Sb_0
+        [46] MaxAB_0
+        [45:38] CExp_0
+        [37:33] InputExc_0
+        [32:0] Sum_4
+      */          
+      pipe_6 = {stage_4_5[`EXPONENT+`EXPONENT+11], Shift_5[4:0], stage_4_5[`DWIDTH+`EXPONENT+10:`DWIDTH+1], SumS_5[`DWIDTH:0]} ;  
+      /* pipe_7 :
+        [56] operation
+        [55:51] Shift_5
+        [50] PSgn_4
+        [49] Opr_4
+        [48] Sa_0
+        [47] Sb_0
+        [46] MaxAB_0
+        [45:38] CExp_0
+        [37:33] InputExc_0
+        [32:0] Sum_4
+      */            
+      //pipe_7 = {pipe_6[`DWIDTH+`EXPONENT+16:`DWIDTH+1], SumS_7[`DWIDTH:0]} ;  
+      /* pipe_8:
+        [54] FG_8 
+        [53] operation
+        [52] PSgn_4
+        [51] Sa_0
+        [50] Sb_0
+        [49] MaxAB_0
+        [48:41] CExp_0
+        [40:36] InputExc_8
+        [35:13] NormM_8 
+        [12:4] NormE_8
+        [3] ZeroSum_8
+        [2] NegE_8
+        [1] R_8
+        [0] S_8
+      */        
+      //pipe_8 = {FG_8, pipe_6[`DWIDTH+`EXPONENT+16], pipe_6[`DWIDTH+`EXPONENT+10], pipe_6[`DWIDTH+`EXPONENT+8:`DWIDTH+1], NormM_8[`MANTISSA-1:0], NormE_8[`EXPONENT:0], ZeroSum_8, NegE_8, R_8, S_8} ; 
+      /* pipe_9:
+        [40:9] P_int
+        [8] NegE_8
+        [7] R_8
+        [6] S_8
+        [5:1] InputExc_8
+        [0] EOF
+      */        
+      pipe_9 = {P_int[`DWIDTH-1:0], stage_6_7[2], stage_6_7[1], stage_6_7[0], stage_6_7[`EXPONENT+`MANTISSA+9:`EXPONENT+`MANTISSA+5], EOF} ;  
+    end
+  end   
+
+
+always@(posedge clk)begin
+  if(rst)begin
+      q1_valid = 0;
+      q2_valid = 0;
+      q3_valid = 0;
+  end
+  else begin
+      q1_valid <= en;
+      q2_valid <= q1_valid;
+      q3_valid <= q2_valid;
+  end
+end
+  
+endmodule
+
+//////////////////////////////////////////////////////////////////////////////////
+//
+// Create Date:     16:49:15 10/16/2012 
+// Module Name:     FPAddSub_PrealignModule
+// Project Name:    Floating Point Project
+// Author:        Fredrik Brosser
+//
+// Description:   The pre-alignment module is responsible for taking the inputs
+//              apart and checking the parts for exceptions.
+//              The exponent difference is also calculated in this module.
+//
+//////////////////////////////////////////////////////////////////////////////////
+
+module FPAddSub_PrealignModule(
+    A,
+    B,
+    operation,
+    Sa,
+    Sb,
+    ShiftDet,
+    InputExc,
+    Aout,
+    Bout,
+    Opout
+  );
+  
+  // Input ports
+  input [`DWIDTH-1:0] A ;                   // Input A, a 32-bit floating point number
+  input [`DWIDTH-1:0] B ;                   // Input B, a 32-bit floating point number
+  input operation ;
+  
+  // Output ports
+  output Sa ;                       // A's sign
+  output Sb ;                       // B's sign
+  output [9:0] ShiftDet ;
+  output [4:0] InputExc ;               // Input numbers are exceptions
+  output [`DWIDTH-2:0] Aout ;
+  output [`DWIDTH-2:0] Bout ;
+  output Opout ;
+  
+  // Internal signals                 // If signal is high...
+  wire ANaN ;                       // A is a NaN (Not-a-Number)
+  wire BNaN ;                       // B is a NaN
+  wire AInf ;                       // A is infinity
+  wire BInf ;                       // B is infinity
+  wire [`EXPONENT-1:0] DAB ;                    // ExpA - ExpB          
+  wire [`EXPONENT-1:0] DBA ;                    // ExpB - ExpA  
+  
+  assign ANaN = &(A[`DWIDTH-2:`DWIDTH-1-`EXPONENT]) & |(A[`MANTISSA-1:0]) ;   // All one exponent and not all zero mantissa - NaN
+  assign BNaN = &(B[`DWIDTH-2:`DWIDTH-1-`EXPONENT]) & |(B[`MANTISSA-1:0]);    // All one exponent and not all zero mantissa - NaN
+  assign AInf = &(A[`DWIDTH-2:`DWIDTH-1-`EXPONENT]) & ~|(A[`MANTISSA-1:0]) ;  // All one exponent and all zero mantissa - Infinity
+  assign BInf = &(B[`DWIDTH-2:`DWIDTH-1-`EXPONENT]) & ~|(B[`MANTISSA-1:0]) ;  // All one exponent and all zero mantissa - Infinity
+  
+  // Put all flags into exception vector
+  assign InputExc = {(ANaN | BNaN | AInf | BInf), ANaN, BNaN, AInf, BInf} ;
+  
+  //assign DAB = (A[30:23] - B[30:23]) ;
+  //assign DBA = (B[30:23] - A[30:23]) ;
+  assign DAB = (A[`DWIDTH-2:`MANTISSA] + ~(B[`DWIDTH-2:`MANTISSA]) + 1) ;
+  assign DBA = (B[`DWIDTH-2:`MANTISSA] + ~(A[`DWIDTH-2:`MANTISSA]) + 1) ;
+  
+  assign Sa = A[`DWIDTH-1] ;                  // A's sign bit
+  assign Sb = B[`DWIDTH-1] ;                  // B's sign bit
+  assign ShiftDet = {DBA[4:0], DAB[4:0]} ;    // Shift data
+  assign Opout = operation ;
+  assign Aout = A[`DWIDTH-2:0] ;
+  assign Bout = B[`DWIDTH-2:0] ;
+  
+endmodule
+
+//////////////////////////////////////////////////////////////////////////////////
+//
+// Create Date:     16:49:15 10/16/2012 
+// Module Name:     FPAddSub_AlignModule
+// Project Name:    Floating Point Project
+// Author:        Fredrik Brosser
+//
+// Description:   The alignment module determines the larger input operand and
+//              sets the mantissas, shift and common exponent accordingly.
+//
+//////////////////////////////////////////////////////////////////////////////////
+
+module FPAddSub_AlignModule (
+    A,
+    B,
+    ShiftDet,
+    CExp,
+    MaxAB,
+    Shift,
+    Mmin,
+    Mmax
+  );
+  
+  // Input ports
+  input [`DWIDTH-2:0] A ;               // Input A, a 32-bit floating point number
+  input [`DWIDTH-2:0] B ;               // Input B, a 32-bit floating point number
+  input [9:0] ShiftDet ;
+  
+  // Output ports
+  output [`EXPONENT-1:0] CExp ;             // Common Exponent
+  output MaxAB ;                  // Incidates larger of A and B (0/A, 1/B)
+  output [4:0] Shift ;              // Number of steps to smaller mantissa shift right
+  output [`MANTISSA-1:0] Mmin ;             // Smaller mantissa 
+  output [`MANTISSA-1:0] Mmax ;             // Larger mantissa
+  
+  // Internal signals
+  //wire BOF ;                    // Check for shifting overflow if B is larger
+  //wire AOF ;                    // Check for shifting overflow if A is larger
+  
+  assign MaxAB = (A[`DWIDTH-2:0] < B[`DWIDTH-2:0]) ;  
+  //assign BOF = ShiftDet[9:5] < 25 ;   // Cannot shift more than 25 bits
+  //assign AOF = ShiftDet[4:0] < 25 ;   // Cannot shift more than 25 bits
+  
+  // Determine final shift value
+  //assign Shift = MaxAB ? (BOF ? ShiftDet[9:5] : 5'b11001) : (AOF ? ShiftDet[4:0] : 5'b11001) ;
+  
+  assign Shift = MaxAB ? ShiftDet[9:5] : ShiftDet[4:0] ;
+  
+  // Take out smaller mantissa and append shift space
+  assign Mmin = MaxAB ? A[`MANTISSA-1:0] : B[`MANTISSA-1:0] ; 
+  
+  // Take out larger mantissa 
+  assign Mmax = MaxAB ? B[`MANTISSA-1:0]: A[`MANTISSA-1:0] ;  
+  
+  // Common exponent
+  assign CExp = (MaxAB ? B[`MANTISSA+`EXPONENT-1:`MANTISSA] : A[`MANTISSA+`EXPONENT-1:`MANTISSA]) ;   
+  
+endmodule
+
+//////////////////////////////////////////////////////////////////////////////////
+//
+// Create Date:    16:49:36 10/16/2012 
+// Module Name:    FPAddSub_AlignShift1
+// Project Name:   Floating Point Project
+// Author:       Fredrik Brosser
+//
+// Description:  Alignment shift stage 1, performs 16|12|8|4 shift
+//
+//////////////////////////////////////////////////////////////////////////////////
+
+module FPAddSub_AlignShift1(
+    MminP,
+    Shift,
+    Mmin
+  );
+  
+  // Input ports
+  input [`MANTISSA-1:0] MminP ;           // Smaller mantissa after 16|12|8|4 shift
+  input [2:0] Shift ;           // Shift amount
+  
+  // Output ports
+  output [`MANTISSA:0] Mmin ;           // The smaller mantissa
+  
+  // Internal signals
+  reg   [`MANTISSA:0]   Lvl1;
+  reg   [`MANTISSA:0]   Lvl2;
+  wire    [2*`MANTISSA+1:0]    Stage1;  
+  integer           i;                // Loop variable
+  
+  always @(*) begin           
+    // Rotate by 16?
+    //Lvl1 <= Shift[2] ? {17'b00000000000000001, MminP[22:16]} : {1'b1, MminP}; 
+    Lvl1 <= Shift[2] ? {11'b0000000000} : {1'b1, MminP}; 
+    
+  end
+  
+  assign Stage1 = { 11'b0, Lvl1};
+  
+  always @(*) begin             // Rotate {0 | 4 | 8 | 12} bits
+    case (Shift[1:0])
+      // Rotate by 0  
+      2'b00:  Lvl2 <= Stage1[`MANTISSA:0];            
+      // Rotate by 4  
+      2'b01:  begin for (i=0; i<=`MANTISSA; i=i+1) begin Lvl2[i] <= Stage1[i+4]; end Lvl2[`MANTISSA:`MANTISSA-3] <= 0; end
+      // Rotate by 8
+      2'b10:  begin for (i=0; i<=`MANTISSA; i=i+1) begin Lvl2[i] <= Stage1[i+8]; end Lvl2[`MANTISSA:`MANTISSA-7] <= 0; end
+      // Rotate by 12 
+      2'b11: Lvl2[`MANTISSA: 0] <= 0; 
+      //2'b11:  begin for (i=0; i<=`MANTISSA; i=i+1) begin Lvl2[i] <= Stage1[i+12]; end Lvl2[`MANTISSA:`MANTISSA-12] <= 0; end
+    endcase
+  end
+  
+  // Assign output to next shift stage
+  assign Mmin = Lvl2;
+  
+endmodule
+
+//////////////////////////////////////////////////////////////////////////////////
+//
+// Create Date:    16:50:05 10/16/2012 
+// Module Name:    FPAddSub_AlignShift2
+// Project Name:   Floating Point Project
+// Author:       Fredrik Brosser
+//
+// Description:  Alignment shift stage 2, performs 3|2|1 shift
+//
+//////////////////////////////////////////////////////////////////////////////////
+
+module FPAddSub_AlignShift2(
+    MminP,
+    Shift,
+    Mmin
+  );
+  
+  // Input ports
+  input [`MANTISSA:0] MminP ;           // Smaller mantissa after 16|12|8|4 shift
+  input [1:0] Shift ;           // Shift amount
+  
+  // Output ports
+  output [`MANTISSA:0] Mmin ;           // The smaller mantissa
+  
+  // Internal Signal
+  reg   [`MANTISSA:0]   Lvl3;
+  wire    [2*`MANTISSA+1:0]    Stage2;  
+  integer           j;               // Loop variable
+  
+  assign Stage2 = {11'b0, MminP};
+
+  always @(*) begin    // Rotate {0 | 1 | 2 | 3} bits
+    case (Shift[1:0])
+      // Rotate by 0
+      2'b00:  Lvl3 <= Stage2[`MANTISSA:0];   
+      // Rotate by 1
+      2'b01:  begin for (j=0; j<=`MANTISSA; j=j+1)  begin Lvl3[j] <= Stage2[j+1]; end Lvl3[`MANTISSA] <= 0; end 
+      // Rotate by 2
+      2'b10:  begin for (j=0; j<=`MANTISSA; j=j+1)  begin Lvl3[j] <= Stage2[j+2]; end Lvl3[`MANTISSA:`MANTISSA-1] <= 0; end 
+      // Rotate by 3
+      2'b11:  begin for (j=0; j<=`MANTISSA; j=j+1)  begin Lvl3[j] <= Stage2[j+3]; end Lvl3[`MANTISSA:`MANTISSA-2] <= 0; end     
+    endcase
+  end
+  
+  // Assign output
+  assign Mmin = Lvl3;           // Take out smaller mantissa        
+
+endmodule
+
+//////////////////////////////////////////////////////////////////////////////////
+//
+// Create Date:    11:35:05 09/05/2012 
+// Module Name:    FPAddSub_ExecutionModule 
+// Project Name:   Floating Point Project
+// Author:       Fredrik Brosser
+//
+// Description:  Module that executes the addition or subtraction on mantissas.
+//
+//////////////////////////////////////////////////////////////////////////////////
+
+module FPAddSub_ExecutionModule(
+    Mmax,
+    Mmin,
+    Sa,
+    Sb,
+    MaxAB,
+    OpMode,
+    Sum,
+    PSgn,
+    Opr
+    );
+
+  // Input ports
+  input [`MANTISSA-1:0] Mmax ;          // The larger mantissa
+  input [`MANTISSA:0] Mmin ;          // The smaller mantissa
+  input Sa ;                // Sign bit of larger number
+  input Sb ;                // Sign bit of smaller number
+  input MaxAB ;             // Indicates the larger number (0/A, 1/B)
+  input OpMode ;              // Operation to be performed (0/Add, 1/Sub)
+  
+  // Output ports
+  output [`DWIDTH:0] Sum ;          // The result of the operation
+  output PSgn ;             // The sign for the result
+  output Opr ;              // The effective (performed) operation
+
+  assign Opr = (OpMode^Sa^Sb);    // Resolve sign to determine operation
+
+  // Perform effective operation
+  assign Sum = (OpMode^Sa^Sb) ? ({1'b1, Mmax, 5'b00000} - {Mmin, 5'b00000}) : ({1'b1, Mmax, 5'b00000} + {Mmin, 5'b00000}) ;
+  
+  // Assign result sign
+  assign PSgn = (MaxAB ? Sb : Sa) ;
+
+endmodule
+
+//////////////////////////////////////////////////////////////////////////////////
+//
+// Create Date:    16:05:07 09/07/2012
+// Module Name:    FBAddSub_NormalizeModule
+// Project Name:   Floating Point Project
+// Author:       Fredrik Brosser
+//
+// Description:  Determine the normalization shift amount and perform 16-shift
+//
+//////////////////////////////////////////////////////////////////////////////////
+
+module FPAddSub_NormalizeModule(
+    Sum,
+    Mmin,
+    Shift
+    );
+
+  // Input ports
+  input [`DWIDTH:0] Sum ;         // Mantissa sum including hidden 1 and GRS
+  
+  // Output ports
+  output [`DWIDTH:0] Mmin ;         // Mantissa after 16|0 shift
+  output [4:0] Shift ;          // Shift amount
+  
+  // Determine normalization shift amount by finding leading nought
+  assign Shift =  ( 
+    Sum[16] ? 5'b00000 :   
+    Sum[15] ? 5'b00001 : 
+    Sum[14] ? 5'b00010 : 
+    Sum[13] ? 5'b00011 : 
+    Sum[12] ? 5'b00100 : 
+    Sum[11] ? 5'b00101 : 
+    Sum[10] ? 5'b00110 : 
+    Sum[9] ? 5'b00111 :
+    Sum[8] ? 5'b01000 :
+    Sum[7] ? 5'b01001 :
+    Sum[6] ? 5'b01010 :
+    Sum[5] ? 5'b01011 :
+    Sum[4] ? 5'b01100 : 5'b01101
+  //  Sum[19] ? 5'b01101 :
+  //  Sum[18] ? 5'b01110 :
+  //  Sum[17] ? 5'b01111 :
+  //  Sum[16] ? 5'b10000 :
+  //  Sum[15] ? 5'b10001 :
+  //  Sum[14] ? 5'b10010 :
+  //  Sum[13] ? 5'b10011 :
+  //  Sum[12] ? 5'b10100 :
+  //  Sum[11] ? 5'b10101 :
+  //  Sum[10] ? 5'b10110 :
+  //  Sum[9] ? 5'b10111 :
+  //  Sum[8] ? 5'b11000 :
+  //  Sum[7] ? 5'b11001 : 5'b11010
+  );
+  
+  reg   [`DWIDTH:0]   Lvl1;
+  
+  always @(*) begin
+    // Rotate by 16?
+    Lvl1 <= Shift[4] ? {Sum[8:0], 8'b00000000} : Sum; 
+  end
+  
+  // Assign outputs
+  assign Mmin = Lvl1;           // Take out smaller mantissa
+
+endmodule
+
+//////////////////////////////////////////////////////////////////////////////////
+//
+// Create Date:    16:49:36 10/16/2012 
+// Module Name:    FPAddSub_NormalizeShift1 
+// Project Name:   Floating Point Project
+// Author:       Fredrik Brosser
+//
+// Description:  Normalization shift stage 1, performs 12|8|4|3|2|1|0 shift
+//
+//////////////////////////////////////////////////////////////////////////////////
+
+module FPAddSub_NormalizeShift1(
+    MminP,
+    Shift,
+    Mmin
+  );
+  
+  // Input ports
+  input [`DWIDTH:0] MminP ;           // Smaller mantissa after 16|12|8|4 shift
+  input [3:0] Shift ;           // Shift amount
+  
+  // Output ports
+  output [`DWIDTH:0] Mmin ;           // The smaller mantissa
+  
+  reg   [`DWIDTH:0]   Lvl2;
+  wire    [2*`DWIDTH+1:0]    Stage1;  
+  reg   [`DWIDTH:0]   Lvl3;
+  wire    [2*`DWIDTH+1:0]    Stage2;  
+  integer           i;                // Loop variable
+  
+  assign Stage1 = {MminP, MminP};
+
+  always @(*) begin             // Rotate {0 | 4 | 8 | 12} bits
+    case (Shift[3:2])
+      // Rotate by 0
+      2'b00: Lvl2 <= Stage1[`DWIDTH:0];           
+      // Rotate by 4
+      2'b01: begin for (i=2*`DWIDTH+1; i>=`DWIDTH+1; i=i-1) begin Lvl2[i-33] <= Stage1[i-4]; end Lvl2[3:0] <= 0; end
+      // Rotate by 8
+      2'b10: begin for (i=2*`DWIDTH+1; i>=`DWIDTH+1; i=i-1) begin Lvl2[i-33] <= Stage1[i-8]; end Lvl2[7:0] <= 0; end
+      // Rotate by 12
+      2'b11: begin for (i=2*`DWIDTH+1; i>=`DWIDTH+1; i=i-1) begin Lvl2[i-33] <= Stage1[i-12]; end Lvl2[11:0] <= 0; end
+    endcase
+  end
+  
+  assign Stage2 = {Lvl2, Lvl2};
+
+  always @(*) begin               // Rotate {0 | 1 | 2 | 3} bits
+    case (Shift[1:0])
+      // Rotate by 0
+      2'b00:  Lvl3 <= Stage2[`DWIDTH:0];
+      // Rotate by 1
+      2'b01: begin for (i=2*`DWIDTH+1; i>=`DWIDTH+1; i=i-1) begin Lvl3[i-`DWIDTH-1] <= Stage2[i-1]; end Lvl3[0] <= 0; end 
+      // Rotate by 2
+      2'b10: begin for (i=2*`DWIDTH+1; i>=`DWIDTH+1; i=i-1) begin Lvl3[i-`DWIDTH-1] <= Stage2[i-2]; end Lvl3[1:0] <= 0; end
+      // Rotate by 3
+      2'b11: begin for (i=2*`DWIDTH+1; i>=`DWIDTH+1; i=i-1) begin Lvl3[i-`DWIDTH-1] <= Stage2[i-3]; end Lvl3[2:0] <= 0; end
+    endcase
+  end
+  
+  // Assign outputs
+  assign Mmin = Lvl3;           // Take out smaller mantissa      
+  
+endmodule
+
+//////////////////////////////////////////////////////////////////////////////////
+//
+// Create Date:    17:34:18 10/16/2012 
+// Module Name:    FPAddSub_NormalizeShift2 
+// Project Name:   Floating Point Project
+// Author:       Fredrik Brosser
+//
+// Description:  Normalization shift stage 2, calculates post-normalization
+//             mantissa and exponent, as well as the bits used in rounding    
+//
+//////////////////////////////////////////////////////////////////////////////////
+
+module FPAddSub_NormalizeShift2(
+    PSSum,
+    CExp,
+    Shift,
+    NormM,
+    NormE,
+    ZeroSum,
+    NegE,
+    R,
+    S,
+    FG
+  );
+  
+  // Input ports
+  input [`DWIDTH:0] PSSum ;         // The Pre-Shift-Sum
+  input [`EXPONENT-1:0] CExp ;
+  input [4:0] Shift ;         // Amount to be shifted
+
+  // Output ports
+  output [`MANTISSA-1:0] NormM ;        // Normalized mantissa
+  output [`EXPONENT:0] NormE ;          // Adjusted exponent
+  output ZeroSum ;            // Zero flag
+  output NegE ;             // Flag indicating negative exponent
+  output R ;                // Round bit
+  output S ;                // Final sticky bit
+  output FG ;
+
+  // Internal signals
+  wire MSBShift ;           // Flag indicating that a second shift is needed
+  wire [`EXPONENT:0] ExpOF ;          // MSB set in sum indicates overflow
+  wire [`EXPONENT:0] ExpOK ;          // MSB not set, no adjustment
+  
+  // Calculate normalized exponent and mantissa, check for all-zero sum
+  assign MSBShift = PSSum[`DWIDTH] ;    // Check MSB in unnormalized sum
+  assign ZeroSum = ~|PSSum ;      // Check for all zero sum
+  assign ExpOK = CExp - Shift ;   // Adjust exponent for new normalized mantissa
+  assign NegE = ExpOK[`EXPONENT] ;      // Check for exponent overflow
+  assign ExpOF = CExp - Shift + 1'b1 ;    // If MSB set, add one to exponent(x2)
+  assign NormE = MSBShift ? ExpOF : ExpOK ;     // Check for exponent overflow
+  assign NormM = PSSum[`DWIDTH-1:`EXPONENT+1] ;   // The new, normalized mantissa
+  
+  // Also need to compute sticky and round bits for the rounding stage
+  assign FG = PSSum[`EXPONENT] ; 
+  assign R = PSSum[`EXPONENT-1] ;
+  assign S = |PSSum[`EXPONENT-2:0] ;
+  
+endmodule
+
+//////////////////////////////////////////////////////////////////////////////////
+//
+// Create Date:    11:33:28 09/11/2012 
+// Module Name:    FPAddSub_RoundModule 
+// Project Name:   Floating Point Project
+// Author:       Fredrik Brosser
+//
+// Description:  Performs 'Round to nearest, tie to even'-rounding on the
+//             normalized mantissa according to the G, R, S bits. Calculates
+//             final result and checks for exponent overflow.
+//
+//////////////////////////////////////////////////////////////////////////////////
+
+module FPAddSub_RoundModule(
+    ZeroSum,
+    NormE,
+    NormM,
+    R,
+    S,
+    G,
+    Sa,
+    Sb,
+    Ctrl,
+    MaxAB,
+    Z,
+    EOF
+    );
+
+  // Input ports
+  input ZeroSum ;         // Sum is zero
+  input [`EXPONENT:0] NormE ;       // Normalized exponent
+  input [`MANTISSA-1:0] NormM ;       // Normalized mantissa
+  input R ;             // Round bit
+  input S ;             // Sticky bit
+  input G ;
+  input Sa ;              // A's sign bit
+  input Sb ;              // B's sign bit
+  input Ctrl ;            // Control bit (operation)
+  input MaxAB ;
+  
+  // Output ports
+  output [`DWIDTH-1:0] Z ;          // Final result
+  output EOF ;
+  
+  // Internal signals
+  wire [`MANTISSA:0] RoundUpM ;     // Rounded up sum with room for overflow
+  wire [`MANTISSA-1:0] RoundM ;       // The final rounded sum
+  wire [`EXPONENT:0] RoundE ;       // Rounded exponent (note extra bit due to poential overflow  )
+  wire RoundUp ;            // Flag indicating that the sum should be rounded up
+        wire FSgn;
+  wire ExpAdd ;           // May have to add 1 to compensate for overflow 
+  wire RoundOF ;            // Rounding overflow
+  
+  // The cases where we need to round upwards (= adding one) in Round to nearest, tie to even
+  assign RoundUp = (G & ((R | S) | NormM[0])) ;
+  
+  // Note that in the other cases (rounding down), the sum is already 'rounded'
+  assign RoundUpM = (NormM + 1) ;               // The sum, rounded up by 1
+  assign RoundM = (RoundUp ? RoundUpM[`MANTISSA-1:0] : NormM) ;   // Compute final mantissa 
+  assign RoundOF = RoundUp & RoundUpM[`MANTISSA] ;        // Check for overflow when rounding up
+
+  // Calculate post-rounding exponent
+  assign ExpAdd = (RoundOF ? 1'b1 : 1'b0) ;         // Add 1 to exponent to compensate for overflow
+  assign RoundE = ZeroSum ? 5'b00000 : (NormE + ExpAdd) ;               // Final exponent
+
+  // If zero, need to determine sign according to rounding
+  assign FSgn = (ZeroSum & (Sa ^ Sb)) | (ZeroSum ? (Sa & Sb & ~Ctrl) : ((~MaxAB & Sa) | ((Ctrl ^ Sb) & (MaxAB | Sa)))) ;
+
+  // Assign final result
+  assign Z = {FSgn, RoundE[`EXPONENT-1:0], RoundM[`MANTISSA-1:0]} ;
+  
+  // Indicate exponent overflow
+  assign EOF = RoundE[`EXPONENT];
+  
+endmodule
+
+//////////////////////////////////////////////////////////////////////////////////
+//
+// Create Date:    13:00:02 16/11/2012 
+// Module Name:    FPAddSub_ExceptionModule 
+// Project Name:   Floating Point Project
+// Author:       Fredrik Brosser
+//
+// Description:  Check the final result for exception conditions and set
+//             flags accordingly.
+//
+//////////////////////////////////////////////////////////////////////////////////
+
+module FPAddSub_ExceptionModule(
+    Z,
+    NegE,
+    R,
+    S,
+    InputExc,
+    EOF,
+    P,
+    Flags
+    );
+   
+  // Input ports
+  input [`DWIDTH-1:0] Z ;         // Final product
+  input NegE ;            // Negative exponent?
+  input R ;             // Round bit
+  input S ;             // Sticky bit
+  input [4:0] InputExc ;      // Exceptions in inputs A and B
+  input EOF ;
+  
+  // Output ports
+  output [`DWIDTH-1:0] P ;          // Final result
+  output [4:0] Flags ;        // Exception flags
+  
+  // Internal signals
+  wire Overflow ;         // Overflow flag
+  wire Underflow ;          // Underflow flag
+  wire DivideByZero ;       // Divide-by-Zero flag (always 0 in Add/Sub)
+  wire Invalid ;            // Invalid inputs or result
+  wire Inexact ;            // Result is inexact because of rounding
+  
+  // Exception flags
+  
+  // Result is too big to be represented
+  assign Overflow = EOF | InputExc[1] | InputExc[0] ;
+  
+  // Result is too small to be represented
+  assign Underflow = NegE & (R | S);
+  
+  // Infinite result computed exactly from finite operands
+  assign DivideByZero = &(Z[`MANTISSA+`EXPONENT-1:`MANTISSA]) & ~|(Z[`MANTISSA+`EXPONENT-1:`MANTISSA]) & ~InputExc[1] & ~InputExc[0];
+  
+  // Invalid inputs or operation
+  assign Invalid = |(InputExc[4:2]) ;
+  
+  // Inexact answer due to rounding, overflow or underflow
+  assign Inexact = (R | S) | Overflow | Underflow;
+  
+  // Put pieces together to form final result
+  assign P = Z ;
+  
+  // Collect exception flags  
+  assign Flags = {Overflow, Underflow, DivideByZero, Invalid, Inexact} ;  
+  
+endmodule
+
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/FPAddSub.v
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/FPMult_16.v
+//////////////////////////////////////////////////////////////////////
+//`define EXPONENT 5
+//`define MANTISSA 10
+`define EXPONENT 5
+`define MANTISSA 10
+`define ACTUAL_MANTISSA 11
+`define EXPONENT_LSB 10
+`define EXPONENT_MSB 14
+`define MANTISSA_LSB 0
+`define MANTISSA_MSB 9
+`define MANTISSA_MUL_SPLIT_LSB 3
+`define MANTISSA_MUL_SPLIT_MSB 9
+`define SIGN 1
+`define SIGN_LOC 15
+`define DWIDTH (`SIGN+`EXPONENT+`MANTISSA)
+`define IEEE_COMPLIANCE 1
+//////////////////////////////////////////////////////////////////////////////////
+//
+// Create Date:    08:40:21 09/19/2012 
+// Module Name:    FPMult
+// Project Name:   Floating Point Project
+// Author:       Fredrik Brosser
+//
+//////////////////////////////////////////////////////////////////////////////////
+
+module FPMult_16(
+    clk,
+    rst,
+                en,
+    a,
+    b,
+    result,
+                valid,
+    flags
+    );
+  
+  // Input Ports
+  input clk ;             // Clock
+  input rst ;
+        input en;             // Reset signal
+  input [`DWIDTH-1:0] a;          // Input A, a 32-bit floating point number
+  input [`DWIDTH-1:0] b;          // Input B, a 32-bit floating point number
+  
+  // Output ports
+  output valid;
+  output [`DWIDTH-1:0] result ;         // Product, result of the operation, 32-bit FP number
+  output [4:0] flags ;        // Flags indicating exceptions according to IEEE754
+  
+  // Internal signals
+  wire [31:0] Z_int ;       // Product, result of the operation, 32-bit FP number
+  wire [4:0] Flags_int ;      // Flags indicating exceptions according to IEEE754
+  
+  wire Sa ;             // A's sign
+  wire Sb ;             // B's sign
+  wire Sp ;             // Product sign
+  wire [`EXPONENT-1:0] Ea ;         // A's exponent
+  wire [`EXPONENT-1:0] Eb ;         // B's exponent
+  wire [2*`MANTISSA+1:0] Mp ;         // Product mantissa
+  wire [4:0] InputExc ;     // Exceptions in inputs
+  wire [`MANTISSA-1:0] NormM ;        // Normalized mantissa
+  wire [`EXPONENT:0] NormE ;        // Normalized exponent
+  wire [`MANTISSA:0] RoundM ;       // Normalized mantissa
+  wire [`EXPONENT:0] RoundE ;       // Normalized exponent
+  wire [`MANTISSA:0] RoundMP ;        // Normalized mantissa
+  wire [`EXPONENT:0] RoundEP ;        // Normalized exponent
+  wire GRS ;
+
+  //reg [63:0] pipe_0;      // Pipeline register Input->Prep
+  reg [2*`DWIDTH-1:0] pipe_0;     // Pipeline register Input->Prep
+  wire [2*`DWIDTH-1:0] stage_0;     // Pipeline register Input->Prep
+
+  //reg [92:0] pipe_1;      // Pipeline register Prep->Execute
+  reg [3*`MANTISSA+2*`EXPONENT+7:0] pipe_1;     // Pipeline register Prep->Execute
+        wire [3*`MANTISSA+2*`EXPONENT+7:0] stage_1; 
+  //reg [38:0] pipe_2;      // Pipeline register Execute->Normalize
+  reg [`MANTISSA+`EXPONENT+7:0] pipe_2;     // Pipeline register Execute->Normalize
+  reg q1_valid;
+        reg q2_valid;
+        reg q3_valid;
+  //reg [72:0] pipe_3;      // Pipeline register Normalize->Round
+  reg [2*`MANTISSA+2*`EXPONENT+10:0] pipe_3;      // Pipeline register Normalize->Round
+
+  //reg [36:0] pipe_4;      // Pipeline register Round->Output
+  reg [`DWIDTH+4:0] pipe_4;     // Pipeline register Round->Output
+  
+  assign result = pipe_4[`DWIDTH+4:5] ;
+  assign flags = pipe_4[4:0] ;
+  
+        assign stage_0 = {a,b};
+        assign valid = q3_valid;
+  // Prepare the operands for alignment and check for exceptions
+  FPMult_PrepModule PrepModule(clk, rst, stage_0[2*`DWIDTH-1:`DWIDTH], stage_0[`DWIDTH-1:0], Sa, Sb, Ea[`EXPONENT-1:0], Eb[`EXPONENT-1:0], Mp[2*`MANTISSA+1:0], InputExc[4:0]) ;
+      
+        assign stage_1 = {stage_0[`DWIDTH+`MANTISSA-1:`DWIDTH], stage_0[8:0], Sa, Sb, Ea[`EXPONENT-1:0], Eb[`EXPONENT-1:0], Mp[2*`MANTISSA+1:0], InputExc[4:0]};
+
+  // Perform (unsigned) mantissa multiplication
+  FPMult_ExecuteModule ExecuteModule(stage_1[3*`MANTISSA+`EXPONENT*2+7:2*`MANTISSA+2*`EXPONENT+8], stage_1[2*`MANTISSA+2*`EXPONENT+7:2*`MANTISSA+7], stage_1[2*`MANTISSA+6:5], stage_1[2*`MANTISSA+2*`EXPONENT+6:2*`MANTISSA+`EXPONENT+7], stage_1[2*`MANTISSA+`EXPONENT+6:2*`MANTISSA+7], stage_1[2*`MANTISSA+2*`EXPONENT+8], stage_1[2*`MANTISSA+2*`EXPONENT+7], Sp, NormE[`EXPONENT:0], NormM[`MANTISSA-1:0], GRS) ;
+
+  // Round result and if necessary, perform a second (post-rounding) normalization step
+  FPMult_NormalizeModule NormalizeModule(pipe_2[`MANTISSA-1:0], pipe_2[`MANTISSA+`EXPONENT:`MANTISSA], RoundE[`EXPONENT:0], RoundEP[`EXPONENT:0], RoundM[`MANTISSA:0], RoundMP[`MANTISSA:0]) ;    
+
+  // Round result and if necessary, perform a second (post-rounding) normalization step
+  //FPMult_RoundModule RoundModule(pipe_3[47:24], pipe_3[23:0], pipe_3[65:57], pipe_3[56:48], pipe_3[66], pipe_3[67], pipe_3[72:68], Z_int[31:0], Flags_int[4:0]) ;   
+  FPMult_RoundModule RoundModule(pipe_3[2*`MANTISSA+1:`MANTISSA+1], pipe_3[`MANTISSA:0], pipe_3[2*`MANTISSA+2*`EXPONENT+3:2*`MANTISSA+`EXPONENT+3], pipe_3[2*`MANTISSA+`EXPONENT+2:2*`MANTISSA+2], pipe_3[2*`MANTISSA+2*`EXPONENT+4], pipe_3[2*`MANTISSA+2*`EXPONENT+5], pipe_3[2*`MANTISSA+2*`EXPONENT+10:2*`MANTISSA+2*`EXPONENT+6], Z_int[`DWIDTH-1:0], Flags_int[4:0]) ;    
+
+  always @ (posedge clk) begin  
+    if(rst) begin
+      //pipe_0 = 0;
+      //pipe_1 = 0;
+      pipe_2 = 0; 
+      pipe_3 = 0;
+      pipe_4 = 0;
+    end 
+    else begin    
+      /* PIPE 0
+        [63:32] A
+        [31:0] B
+      */
+      //pipe_0 = {a, b} ;
+
+      /* PIPE 1
+        [70] Sa
+        [69] Sb
+        [68:61] Ea
+        [60:53] Eb
+        [52:5] Mp
+        [4:0] InputExc
+      */
+      //pipe_1 <= {pipe_0[`DWIDTH+`MANTISSA-1:`DWIDTH], pipe_0[`MANTISSA_MUL_SPLIT_LSB-1:0], Sa, Sb, Ea[`EXPONENT-1:0], Eb[`EXPONENT-1:0], Mp[2*`MANTISSA-1:0], InputExc[4:0]} ;
+      //pipe_1 = {pipe_0[`DWIDTH+`MANTISSA-1:`DWIDTH], pipe_0[8:0], Sa, Sb, Ea[`EXPONENT-1:0], Eb[`EXPONENT-1:0], Mp[2*`MANTISSA+1:0], InputExc[4:0]} ;
+      /* PIPE 2
+        [38:34] InputExc
+        [33] GRS
+        [32] Sp
+        [31:23] NormE
+        [22:0] NormM
+      */
+      pipe_2 <= {stage_1[4:0], GRS, Sp, NormE[`EXPONENT:0], NormM[`MANTISSA-1:0]} ;
+      /* PIPE 3
+        [72:68] InputExc
+        [67] GRS
+        [66] Sp 
+        [65:57] RoundE
+        [56:48] RoundEP
+        [47:24] RoundM
+        [23:0] RoundMP
+      */
+      pipe_3 <= {pipe_2[`EXPONENT+`MANTISSA+7:`EXPONENT+`MANTISSA+1], RoundE[`EXPONENT:0], RoundEP[`EXPONENT:0], RoundM[`MANTISSA:0], RoundMP[`MANTISSA:0]} ;
+      /* PIPE 4
+        [36:5] Z
+        [4:0] Flags
+      */        
+      pipe_4 <= {Z_int[`DWIDTH-1:0], Flags_int[4:0]} ;
+    end
+  end
+always@(posedge clk)begin
+  if(rst)begin
+       q1_valid <= 0;
+       q2_valid <= 0;
+       q3_valid <= 0;
+  end
+  else begin
+       q1_valid <= en;
+       q2_valid <= q1_valid;
+       q3_valid <= q2_valid;
+  end
+end
+
+
+    
+endmodule
+
+
+module FPMult_PrepModule (
+    clk,
+    rst,
+    a,
+    b,
+    Sa,
+    Sb,
+    Ea,
+    Eb,
+    Mp,
+    InputExc
+  );
+  
+  // Input ports
+  input clk ;
+  input rst ;
+  input [`DWIDTH-1:0] a ;               // Input A, a 32-bit floating point number
+  input [`DWIDTH-1:0] b ;               // Input B, a 32-bit floating point number
+  
+  // Output ports
+  output Sa ;                   // A's sign
+  output Sb ;                   // B's sign
+  output [`EXPONENT-1:0] Ea ;               // A's exponent
+  output [`EXPONENT-1:0] Eb ;               // B's exponent
+  output [2*`MANTISSA+1:0] Mp ;             // Mantissa product
+  output [4:0] InputExc ;           // Input numbers are exceptions
+  
+  // Internal signals             // If signal is high...
+  wire ANaN ;                   // A is a signalling NaN
+  wire BNaN ;                   // B is a signalling NaN
+  wire AInf ;                   // A is infinity
+  wire BInf ;                   // B is infinity
+    wire [`MANTISSA-1:0] Ma;
+    wire [`MANTISSA-1:0] Mb;
+  
+  assign ANaN = &(a[`DWIDTH-2:`MANTISSA]) &  |(a[`DWIDTH-2:`MANTISSA]) ;      // All one exponent and not all zero mantissa - NaN
+  assign BNaN = &(b[`DWIDTH-2:`MANTISSA]) &  |(b[`MANTISSA-1:0]);     // All one exponent and not all zero mantissa - NaN
+  assign AInf = &(a[`DWIDTH-2:`MANTISSA]) & ~|(a[`DWIDTH-2:`MANTISSA]) ;    // All one exponent and all zero mantissa - Infinity
+  assign BInf = &(b[`DWIDTH-2:`MANTISSA]) & ~|(b[`DWIDTH-2:`MANTISSA]) ;    // All one exponent and all zero mantissa - Infinity
+  
+  // Check for any exceptions and put all flags into exception vector
+  assign InputExc = {(ANaN | BNaN | AInf | BInf), ANaN, BNaN, AInf, BInf} ;
+  //assign InputExc = {(ANaN | ANaN | BNaN |BNaN), ANaN, ANaN, BNaN,BNaN} ;
+  
+  // Take input numbers apart
+  assign Sa = a[`DWIDTH-1] ;              // A's sign
+  assign Sb = b[`DWIDTH-1] ;              // B's sign
+  assign Ea = a[`DWIDTH-2:`MANTISSA];           // Store A's exponent in Ea, unless A is an exception
+  assign Eb = b[`DWIDTH-2:`MANTISSA];           // Store B's exponent in Eb, unless B is an exception 
+//    assign Ma = a[`MANTISSA_MSB:`MANTISSA_LSB];
+  //  assign Mb = b[`MANTISSA_MSB:`MANTISSA_LSB];
+  
+
+
+  //assign Mp = ({4'b0001, a[`MANTISSA-1:0]}*{4'b0001, b[`MANTISSA-1:9]}) ;
+  assign Mp = ({1'b1,a[`MANTISSA-1:0]}*{1'b1, b[`MANTISSA-1:0]}) ;
+
+  
+    //We multiply part of the mantissa here
+    //Full mantissa of A
+    //Bits MANTISSA_MUL_SPLIT_MSB:MANTISSA_MUL_SPLIT_LSB of B
+   // wire [`ACTUAL_MANTISSA-1:0] inp_A;
+   // wire [`ACTUAL_MANTISSA-1:0] inp_B;
+   // assign inp_A = {1'b1, Ma};
+   // assign inp_B = {{(`MANTISSA-(`MANTISSA_MUL_SPLIT_MSB-`MANTISSA_MUL_SPLIT_LSB+1)){1'b0}}, 1'b1, Mb[`MANTISSA_MUL_SPLIT_MSB:`MANTISSA_MUL_SPLIT_LSB]};
+   // DW02_mult #(`ACTUAL_MANTISSA,`ACTUAL_MANTISSA) u_mult(.A(inp_A), .B(inp_B), .TC(1'b0), .PRODUCT(Mp));
+endmodule
+
+
+module FPMult_ExecuteModule(
+    a,
+    b,
+    MpC,
+    Ea,
+    Eb,
+    Sa,
+    Sb,
+    Sp,
+    NormE,
+    NormM,
+    GRS
+    );
+
+  // Input ports
+  input [`MANTISSA-1:0] a ;
+  input [2*`EXPONENT:0] b ;
+  input [2*`MANTISSA+1:0] MpC ;
+  input [`EXPONENT-1:0] Ea ;            // A's exponent
+  input [`EXPONENT-1:0] Eb ;            // B's exponent
+  input Sa ;                // A's sign
+  input Sb ;                // B's sign
+  
+  // Output ports
+  output Sp ;               // Product sign
+  output [`EXPONENT:0] NormE ;                          // Normalized exponent
+  output [`MANTISSA-1:0] NormM ;                        // Normalized mantissa
+  output GRS ;
+  
+  wire [2*`MANTISSA+1:0] Mp ;
+  
+  assign Sp = (Sa ^ Sb) ;                       // Equal signs give a positive product
+  
+   // wire [`ACTUAL_MANTISSA-1:0] inp_a;
+   // wire [`ACTUAL_MANTISSA-1:0] inp_b;
+   // assign inp_a = {1'b1, a};
+   // assign inp_b = {{(`MANTISSA-`MANTISSA_MUL_SPLIT_LSB){1'b0}}, 1'b0, b};
+   // DW02_mult #(`ACTUAL_MANTISSA,`ACTUAL_MANTISSA) u_mult(.A(inp_a), .B(inp_b), .TC(1'b0), .PRODUCT(Mp_temp));
+   // DW01_add #(2*`ACTUAL_MANTISSA) u_add(.A(Mp_temp), .B(MpC<<`MANTISSA_MUL_SPLIT_LSB), .CI(1'b0), .SUM(Mp), .CO());
+
+  //assign Mp = (MpC<<(2*`EXPONENT+1)) + ({4'b0001, a[`MANTISSA-1:0]}*{1'b0, b[2*`EXPONENT:0]}) ;
+  assign Mp = MpC;
+
+
+  assign NormM = (Mp[2*`MANTISSA+1] ? Mp[2*`MANTISSA:`MANTISSA+1] : Mp[2*`MANTISSA-1:`MANTISSA]);   // Check for overflow
+  assign NormE = (Ea + Eb + Mp[2*`MANTISSA+1]);               // If so, increment exponent
+  
+  assign GRS = ((Mp[`MANTISSA]&(Mp[`MANTISSA+1]))|(|Mp[`MANTISSA-1:0])) ;
+  
+endmodule
+
+module FPMult_NormalizeModule(
+    NormM,
+    NormE,
+    RoundE,
+    RoundEP,
+    RoundM,
+    RoundMP
+    );
+
+  // Input Ports
+  input [`MANTISSA-1:0] NormM ;                 // Normalized mantissa
+  input [`EXPONENT:0] NormE ;                 // Normalized exponent
+
+  // Output Ports
+  output [`EXPONENT:0] RoundE ;
+  output [`EXPONENT:0] RoundEP ;
+  output [`MANTISSA:0] RoundM ;
+  output [`MANTISSA:0] RoundMP ; 
+  
+  assign RoundE = NormE - 15 ;
+  assign RoundEP = NormE - 14 ;
+  assign RoundM = NormM ;
+  assign RoundMP = NormM ;
+
+endmodule
+
+module FPMult_RoundModule(
+    RoundM,
+    RoundMP,
+    RoundE,
+    RoundEP,
+    Sp,
+    GRS,
+    InputExc,
+    Z,
+    Flags
+    );
+
+  // Input Ports
+  input [`MANTISSA:0] RoundM ;                  // Normalized mantissa
+  input [`MANTISSA:0] RoundMP ;                 // Normalized exponent
+  input [`EXPONENT:0] RoundE ;                  // Normalized mantissa + 1
+  input [`EXPONENT:0] RoundEP ;                 // Normalized exponent + 1
+  input Sp ;                        // Product sign
+  input GRS ;
+  input [4:0] InputExc ;
+  
+  // Output Ports
+  output [`DWIDTH-1:0] Z ;                    // Final product
+  output [4:0] Flags ;
+  
+  // Internal Signals
+  wire [`EXPONENT:0] FinalE ;                 // Rounded exponent
+  wire [`MANTISSA:0] FinalM;
+  wire [`MANTISSA:0] PreShiftM;
+  
+  assign PreShiftM = GRS ? RoundMP : RoundM ; // Round up if R and (G or S)
+  
+  // Post rounding normalization (potential one bit shift> use shifted mantissa if there is overflow)
+  assign FinalM = (PreShiftM[`MANTISSA] ? {1'b0, PreShiftM[`MANTISSA:1]} : PreShiftM[`MANTISSA:0]) ;
+  
+  assign FinalE = (PreShiftM[`MANTISSA] ? RoundEP : RoundE) ; // Increment exponent if a shift was done
+  
+  assign Z = {Sp, FinalE[`EXPONENT-1:0], FinalM[`MANTISSA-1:0]} ;   // Putting the pieces together
+  assign Flags = InputExc[4:0];
+
+endmodule
+
+
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/FPMult_16.v
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/permute.v
+//////////////////////////////////////////////////////////////////////
+module permute #(
+  parameter WIDTH = 16,
+  parameter NUMSTAGES = 8,
+  parameter REGIDWIDTH = 8,
+  parameter LOGNUMSTAGES = $clog2(NUMSTAGES)
+)(
+ input clk,
+ input resetn,
+ input read,
+ input en,
+ input row_col_op,
+ input [NUMSTAGES*LOGNUMSTAGES-1:0] row_col_num,
+
+ input load,
+ input [NUMSTAGES * WIDTH-1:0]a,
+
+ input [REGIDWIDTH-1:0] in_dst,
+ input in_dst_we,
+ input [NUMSTAGES-1:0] in_dst_mask,
+
+ output reg [REGIDWIDTH-1:0] out_dst,
+ output reg [NUMSTAGES-1:0] out_dst_mask,
+ output reg out_dst_we,
+ output reg [NUMSTAGES * WIDTH-1 : 0] out
+);
+
+parameter READ_STATE = 2'b00;
+parameter ROWOP_STATE = 2'b01;
+parameter COLOP_STATE = 2'b10;
+parameter WRITE_STATE = 2'b11;
+
+wire [NUMSTAGES * NUMSTAGES * WIDTH - 1:0] data;
+
+reg [NUMSTAGES * LOGNUMSTAGES-1:0 ] rowsel;
+reg [NUMSTAGES * LOGNUMSTAGES-1:0 ] colsel;
+
+reg [LOGNUMSTAGES:0] count;
+reg [31:0] i;
+
+reg [1:0] p_state, n_state;
+reg opsel;
+reg [NUMSTAGES-1:0] load_en;
+reg shuffle;
+reg [NUMSTAGES * NUMSTAGES * WIDTH -1: 0] data_in;
+
+always@(posedge clk)begin
+  if(!resetn)begin
+    out_dst <= 0;
+    out_dst_we <= 0;
+    out_dst_mask <= 0;
+  end
+  else begin
+    out_dst <= in_dst;
+    out_dst_we <= in_dst_we;
+    out_dst_mask <= in_dst_mask;
+  end
+end
+
+
+genvar g_i,g_j;
+
+generate
+  for(g_i = 0; g_i < NUMSTAGES; g_i = g_i + 1)begin
+    for(g_j = 0; g_j < NUMSTAGES; g_j = g_j + 1)begin
+       permute_elm #(.WIDTH(WIDTH), .MUXWIDTH(NUMSTAGES), .MUXSEL(LOGNUMSTAGES)) inst_elm(
+         .clk(clk),
+         .resetn(resetn),
+         .row_sel(rowsel[g_i * LOGNUMSTAGES +: LOGNUMSTAGES]),
+         .col_sel(colsel[g_j * LOGNUMSTAGES +: LOGNUMSTAGES]),
+         .row_col_op(opsel),
+         .in_row_data(data[((g_i+1) * NUMSTAGES * WIDTH)-1 : g_i * (NUMSTAGES * WIDTH)]),
+         .in_col_data({data[(( 0 * NUMSTAGES * WIDTH) + g_j * WIDTH) +: WIDTH ],
+                       data[(( 1 * NUMSTAGES * WIDTH) + g_j * WIDTH) +: WIDTH ],
+                       data[(( 2 * NUMSTAGES * WIDTH) + g_j * WIDTH) +: WIDTH ],
+                       data[(( 3 * NUMSTAGES * WIDTH) + g_j * WIDTH) +: WIDTH ],
+                       data[(( 4 * NUMSTAGES * WIDTH) + g_j * WIDTH) +: WIDTH ],
+                       data[(( 5 * NUMSTAGES * WIDTH) + g_j * WIDTH) +: WIDTH ],
+                       data[(( 6 * NUMSTAGES * WIDTH) + g_j * WIDTH) +: WIDTH ],
+                       data[(( 7 * NUMSTAGES * WIDTH) + g_j * WIDTH) +: WIDTH ]
+                      }),
+         .en(shuffle),
+         .load(load_en[g_i]),
+         .data_in(data_in[g_i * (NUMSTAGES * WIDTH) + g_j * WIDTH +: WIDTH]),
+         .out_data(data[(g_i * NUMSTAGES * WIDTH) + (g_j * WIDTH) +: WIDTH])
+       );
+    end
+  end
+endgenerate
+
+always@(*) begin
+  data_in = 'h0;
+  case(count)
+    4'h0:data_in[1 * (NUMSTAGES * WIDTH)-1: 0 * (NUMSTAGES*WIDTH)] = a;
+    4'h1:data_in[2 * (NUMSTAGES * WIDTH)-1: 1 * (NUMSTAGES*WIDTH)] = a;
+    4'h2:data_in[3 * (NUMSTAGES * WIDTH)-1: 2 * (NUMSTAGES*WIDTH)] = a;
+    4'h3:data_in[4 * (NUMSTAGES * WIDTH)-1: 3 * (NUMSTAGES*WIDTH)] = a;
+    4'h4:data_in[5 * (NUMSTAGES * WIDTH)-1: 4 * (NUMSTAGES*WIDTH)] = a;
+    4'h5:data_in[6 * (NUMSTAGES * WIDTH)-1: 5 * (NUMSTAGES*WIDTH)] = a;
+    4'h6:data_in[7 * (NUMSTAGES * WIDTH)-1: 6 * (NUMSTAGES*WIDTH)] = a;
+    4'h7:data_in[8 * (NUMSTAGES * WIDTH)-1: 7 * (NUMSTAGES*WIDTH)] = a;
+  endcase
+end
+
+always@(*) begin
+  out = 0;
+  case(count)
+    4'h1: out = data[8*(NUMSTAGES * WIDTH) - 1 : 7 * (NUMSTAGES* WIDTH)];
+    4'h2: out = data[7*(NUMSTAGES * WIDTH) - 1 : 6 * (NUMSTAGES* WIDTH)];
+    4'h3: out = data[6*(NUMSTAGES * WIDTH) - 1 : 5 * (NUMSTAGES* WIDTH)];
+    4'h4: out = data[5*(NUMSTAGES * WIDTH) - 1 : 4 * (NUMSTAGES* WIDTH)];
+    4'h5: out = data[4*(NUMSTAGES * WIDTH) - 1 : 3 * (NUMSTAGES* WIDTH)];
+    4'h6: out = data[3*(NUMSTAGES * WIDTH) - 1 : 2 * (NUMSTAGES* WIDTH)];
+    4'h7: out = data[2*(NUMSTAGES * WIDTH) - 1 : 1 * (NUMSTAGES* WIDTH)];
+    4'h8: out = data[1*(NUMSTAGES * WIDTH) - 1 : 0 * (NUMSTAGES* WIDTH)];
+  endcase
+end
+
+
+always@(posedge clk)begin
+  if(!resetn)
+    count <= 'h0;
+  else begin
+    if(en & load)begin
+      count <= count + 1;
+    end
+    else if(en & read)
+      count <= count - 1 ;
+  end
+end
+
+always@(*)begin
+  load_en = 8'h0;
+  if(en & load)begin
+      case(count)
+        3'h0: load_en = 8'h1;
+        3'h1: load_en = 8'h2;
+        3'h2: load_en = 8'h4;
+        3'h3: load_en = 8'h8;
+        3'h4: load_en = 8'h10;
+        3'h5: load_en = 8'h20;
+        3'h6: load_en = 8'h40;
+        3'h7: load_en = 8'h80;
+      endcase
+  end
+end
+
+
+always@(*)begin
+    shuffle = 1'b0;
+    rowsel = {3'h7,3'h6,3'h5,3'h4,3'h3,3'h2,3'h1,3'h0};
+    colsel = {3'h7,3'h6,3'h5,3'h4,3'h3,3'h2,3'h1,3'h0};
+    if(en & ~load & ~read)begin
+        shuffle = 1'b1;
+        rowsel = row_col_num; 
+        colsel = row_col_num;
+        if(row_col_op)
+            opsel = 1'b1; 
+        else
+            opsel = 1'b0; 
+    end
+end
+
+endmodule
+
+
+module permute_elm #(
+  parameter MUXWIDTH = 8,
+  parameter WIDTH = 16,
+  parameter MUXSEL = $clog2(MUXWIDTH)
+)(
+  input clk,
+  input resetn,
+  input [MUXSEL-1:0] row_sel,
+  input [MUXSEL-1:0] col_sel,
+  input row_col_op,
+  input [MUXWIDTH*WIDTH-1:0] in_row_data,  
+  input [MUXWIDTH*WIDTH-1:0] in_col_data,  
+
+  input load,
+  input en,
+  input [WIDTH-1:0] data_in,
+
+  output reg [WIDTH-1:0] out_data
+);
+
+reg [WIDTH-1:0] row_data;
+reg [WIDTH-1:0] col_data;
+reg [WIDTH-1:0] n_data;
+
+always@(*)begin
+  case(row_sel)
+    3'h0:begin row_data = in_row_data[1 * WIDTH -1: 0 * WIDTH]; end
+    3'h1:begin row_data = in_row_data[2 * WIDTH -1: 1 * WIDTH]; end
+    3'h2:begin row_data = in_row_data[3 * WIDTH -1: 2 * WIDTH]; end
+    3'h3:begin row_data = in_row_data[4 * WIDTH -1: 3 * WIDTH]; end
+    3'h4:begin row_data = in_row_data[5 * WIDTH -1: 4 * WIDTH]; end
+    3'h5:begin row_data = in_row_data[6 * WIDTH -1: 5 * WIDTH]; end
+    3'h6:begin row_data = in_row_data[7 * WIDTH -1: 6 * WIDTH]; end
+    3'h7:begin row_data = in_row_data[8 * WIDTH -1: 7 * WIDTH]; end
+  endcase
+  case(col_sel)
+    3'h0:begin col_data = in_col_data[1 * WIDTH -1: 0 * WIDTH]; end
+    3'h1:begin col_data = in_col_data[2 * WIDTH -1: 1 * WIDTH]; end
+    3'h2:begin col_data = in_col_data[3 * WIDTH -1: 2 * WIDTH]; end
+    3'h3:begin col_data = in_col_data[4 * WIDTH -1: 3 * WIDTH]; end
+    3'h4:begin col_data = in_col_data[5 * WIDTH -1: 4 * WIDTH]; end
+    3'h5:begin col_data = in_col_data[6 * WIDTH -1: 5 * WIDTH]; end
+    3'h6:begin col_data = in_col_data[7 * WIDTH -1: 6 * WIDTH]; end
+    3'h7:begin col_data = in_col_data[8 * WIDTH -1: 7 * WIDTH]; end
+  endcase
+  
+  if(row_col_op)
+    n_data = row_data;
+  else
+    n_data = col_data; 
+end
+
+always@(posedge clk)begin
+  if(~resetn)
+    out_data <= 'h0;
+  else
+   if(load)
+     out_data <= data_in;
+   else if(en)
+     out_data <= n_data;
+end
+
+endmodule
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/permute.v
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/reduction_unit.v
+//////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////
+//Module to reduce multiple values (add, max, min) into one final result.
+//////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////
+// Numerics. We use fixed point format:
+//  Most significant 8 bits represent integer part and Least significant 8 bits
+//  represent fraction part
+//  i.e. IIIIIIIIFFFFFFFF = IIIIIIII.FFFFFFFF
+//////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////
+// There are 32 inputs to the reduction unit. We use a tree structure to reduce the 32 values.
+// It is assumed that the number of addressses supplied (end_addr - start_addr + 1) is a multiple
+// of 32. If the real application needs to reduce a number of values that are not a multiple of
+// 32, then the application must pad the values in the input BRAM appropriately
+//////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////
+// A user is expected to use the resetn signal everytime before starting a new reduction operation.
+//////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////
+// Accumulation is done in 20 bits (16 + log(16))
+//////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////
+// Each entry of the RAM contains `NUM_INPUTS (which is 32) values. So,
+// 1 read of the RAM provides all the inputs required for going through
+// the reduction unit once. 
+//////////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////
+// Top module
+////////////////////////////////////////////
+module reduction_layer#(
+ parameter DWIDTH = 16,
+ parameter LOGDWIDTH = $clog2(DWIDTH)
+)(
+  input clk,
+  input resetn, //resets the processing elements
+  input en, //indicates valid reduction operation
+  input  [1:0] reduction_type, //can have 3 values: 0 (Add), 1 (Max), 2 (Min)
+  //input read,
+  input  [8 * DWIDTH -1:0] a, // input data to reduction logic
+  output [8 * DWIDTH -1:0] reduced_out, //output
+  output reg done, //output is valid when done is 1
+  output reg busy,
+  output reg valid
+);
+
+wire [DWIDTH + LOGDWIDTH-1:0] reduced_out_unrounded;
+
+reduction_unit ucu(
+  .clk(clk),
+  .resetn(resetn),
+  .en(en),
+  .inp0(a[1*DWIDTH-1:0*DWIDTH]), 
+  .inp1(a[2*DWIDTH-1:1*DWIDTH]), 
+  .inp2(a[3*DWIDTH-1:2*DWIDTH]), 
+  .inp3(a[4*DWIDTH-1:3*DWIDTH]), 
+  .inp4(a[5*DWIDTH-1:4*DWIDTH]), 
+  .inp5(a[6*DWIDTH-1:5*DWIDTH]), 
+  .inp6(a[7*DWIDTH-1:6*DWIDTH]), 
+  .inp7(a[8*DWIDTH-1:7*DWIDTH]), 
+  .mode(reduction_type),
+  .outp(reduced_out_unrounded)
+);
+defparam
+    ucu.DWIDTH = DWIDTH,
+    ucu.LOGDWIDTH = LOGDWIDTH;
+
+////////////////////////////////////////////////////////////////
+// Rounding of the output of reduction unit (from 20 bits to 16 bits).
+// This is required only when reduction type is "sum"
+////////////////////////////////////////////////////////////////
+rounding #(DWIDTH+LOGDWIDTH, DWIDTH) u_round(.i_data(reduced_out_unrounded), .o_data(reduced_out_add));
+
+assign reduced_out_1 = (reduction_type==2'b0) ? reduced_out_add : reduced_out_unrounded[DWIDTH-1:0];
+//assign reduced_out = {8{reduced_out_1}};
+assign reduced_out = {8{reduced_out_unrounded[DWIDTH-1:0]}};
+
+reg[2:0] count;
+
+always@(posedge clk)begin
+  if(!resetn)begin
+    count <= 3'h0;
+    valid <= 1'b0;
+  end
+  else begin
+    if(en)
+        count <= 3'h4;
+    if( ~en & (count != 3'h0))
+        count <= count - 1;
+    if(~en & (count == 3'h2))
+        valid <= 1'b1;
+    else
+        valid <= 1'b0;
+  end
+end
+
+always@(*)begin
+  if(count != 0)begin
+    busy = 1'b1;
+  end
+  else begin
+    busy = 1'b0;
+  end
+end
+
+always@(posedge clk)begin
+  if(!resetn)begin
+    done <= 1'b0;
+  end
+  else begin
+    if(count == 8)
+      done <= 1'b1;
+    else if(count ==0)
+      done <= 1'b0;
+  end
+end
+
+endmodule
+
+
+///////////////////////////////////////////////////////
+// Processing element. Finds sum, min or max depending on mode
+///////////////////////////////////////////////////////
+module reduction_processing_element #(
+  parameter IN_DWIDTH = 16,
+  parameter OUT_DWIDTH = 4
+)(
+  A, B, OUT, MODE
+);
+
+input [IN_DWIDTH-1:0] A;
+input [IN_DWIDTH-1:0] B;
+output [OUT_DWIDTH-1:0] OUT;
+input [1:0] MODE;
+
+wire [OUT_DWIDTH-1:0] greater;
+wire [OUT_DWIDTH-1:0] smaller;
+wire [OUT_DWIDTH-1:0] sum;
+
+assign greater = (A>B) ? A : B;
+assign smaller = (A<B) ? A : B;
+assign sum = A + B;
+
+assign OUT = (MODE==0) ? sum : 
+             (MODE==1) ? greater :
+             smaller;
+
+endmodule
+
+
+///////////////////////////////////////////////////////
+// Reduction unit. It's a tree of processing elements.
+// There are 32 inputs and one output and 6 stages. 
+//
+// The output is
+// wider (more bits) than the inputs. It has logN more
+// bits (if N is the number of bits in the inputs). This
+// is based on https://zipcpu.com/dsp/2017/07/22/rounding.html.
+// 
+// The last stage is special. It adds the previous 
+// result. This is useful when we have more than 32 inputs
+// to reduce. We send the next set of 32 inputs in the next
+// clock after the first set. 
+// 
+// Each stage of the tree is pipelined.
+///////////////////////////////////////////////////////
+module reduction_unit(
+  clk,
+  resetn,
+  en,
+  inp0, 
+  inp1, 
+  inp2, 
+  inp3, 
+  inp4, 
+  inp5, 
+  inp6, 
+  inp7, 
+
+  mode,
+  outp
+);
+  parameter DWIDTH = 16;
+  parameter LOGDWIDTH = 4;
+
+  input clk;
+  input resetn;
+  input en;
+  input  [DWIDTH-1 : 0] inp0; 
+  input  [DWIDTH-1 : 0] inp1; 
+  input  [DWIDTH-1 : 0] inp2; 
+  input  [DWIDTH-1 : 0] inp3; 
+  input  [DWIDTH-1 : 0] inp4; 
+  input  [DWIDTH-1 : 0] inp5; 
+  input  [DWIDTH-1 : 0] inp6; 
+  input  [DWIDTH-1 : 0] inp7; 
+
+  input [1:0] mode;
+  output [DWIDTH+LOGDWIDTH-1 : 0] outp;
+
+  wire   [DWIDTH+LOGDWIDTH-1 : 0] compute0_out_stage3;
+  reg    [DWIDTH+LOGDWIDTH-1 : 0] compute0_out_stage3_reg;
+  wire   [DWIDTH+LOGDWIDTH-1 : 0] compute1_out_stage3;
+  reg    [DWIDTH+LOGDWIDTH-1 : 0] compute1_out_stage3_reg;
+  wire   [DWIDTH+LOGDWIDTH-1 : 0] compute2_out_stage3;
+  reg    [DWIDTH+LOGDWIDTH-1 : 0] compute2_out_stage3_reg;
+  wire   [DWIDTH+LOGDWIDTH-1 : 0] compute3_out_stage3;
+  reg    [DWIDTH+LOGDWIDTH-1 : 0] compute3_out_stage3_reg;
+
+  wire   [DWIDTH+LOGDWIDTH-1 : 0] compute0_out_stage2;
+  reg    [DWIDTH+LOGDWIDTH-1 : 0] compute0_out_stage2_reg;
+  wire   [DWIDTH+LOGDWIDTH-1 : 0] compute1_out_stage2;
+  reg    [DWIDTH+LOGDWIDTH-1 : 0] compute1_out_stage2_reg;
+
+  wire   [DWIDTH+LOGDWIDTH-1 : 0] compute0_out_stage1;
+  reg    [DWIDTH+LOGDWIDTH-1 : 0] compute0_out_stage1_reg;
+
+  wire   [DWIDTH+LOGDWIDTH-1 : 0] compute0_out_stage0;
+  reg    [DWIDTH+LOGDWIDTH-1 : 0] outp;
+
+  always @(posedge clk) begin
+    if (~resetn) begin
+      outp <= 0;
+      compute0_out_stage3_reg <= 0;
+      compute1_out_stage3_reg <= 0;
+      compute2_out_stage3_reg <= 0;
+      compute3_out_stage3_reg <= 0;
+      compute0_out_stage2_reg <= 0;
+      compute1_out_stage2_reg <= 0;
+      compute0_out_stage1_reg <= 0;
+    end
+
+    else begin
+      if(en)begin
+        compute0_out_stage3_reg <= compute0_out_stage3;
+        compute1_out_stage3_reg <= compute1_out_stage3;
+        compute2_out_stage3_reg <= compute2_out_stage3;
+        compute3_out_stage3_reg <= compute3_out_stage3;
+      end
+      else begin
+        compute0_out_stage3_reg <= 0;
+        compute1_out_stage3_reg <= 0;
+        compute2_out_stage3_reg <= 0;
+        compute3_out_stage3_reg <= 0;
+      end
+
+      compute0_out_stage2_reg <= compute0_out_stage2;
+      compute1_out_stage2_reg <= compute1_out_stage2;
+
+      compute0_out_stage1_reg <= compute0_out_stage1;
+
+      outp <= compute0_out_stage0;
+    end
+  end
+  reduction_processing_element #(.IN_DWIDTH(DWIDTH),.OUT_DWIDTH(DWIDTH+LOGDWIDTH)) compute0_stage3(.A(inp0),.B(inp1),.OUT(compute0_out_stage3), .MODE(mode));
+  reduction_processing_element #(.IN_DWIDTH(DWIDTH),.OUT_DWIDTH(DWIDTH+LOGDWIDTH)) compute1_stage3(.A(inp2),.B(inp3),.OUT(compute1_out_stage3), .MODE(mode));
+  reduction_processing_element #(.IN_DWIDTH(DWIDTH),.OUT_DWIDTH(DWIDTH+LOGDWIDTH)) compute2_stage3(.A(inp4),.B(inp5),.OUT(compute2_out_stage3), .MODE(mode));
+  reduction_processing_element #(.IN_DWIDTH(DWIDTH),.OUT_DWIDTH(DWIDTH+LOGDWIDTH)) compute3_stage3(.A(inp6),.B(inp7),.OUT(compute3_out_stage3), .MODE(mode));
+
+  reduction_processing_element #(.IN_DWIDTH(DWIDTH+LOGDWIDTH),.OUT_DWIDTH(DWIDTH+LOGDWIDTH)) compute0_stage2(.A(compute0_out_stage3_reg),.B(compute1_out_stage3_reg),.OUT(compute0_out_stage2), .MODE(mode));
+  reduction_processing_element #(.IN_DWIDTH(DWIDTH+LOGDWIDTH),.OUT_DWIDTH(DWIDTH+LOGDWIDTH)) compute1_stage2(.A(compute2_out_stage3_reg),.B(compute3_out_stage3_reg),.OUT(compute1_out_stage2), .MODE(mode));
+
+  reduction_processing_element #(.IN_DWIDTH(DWIDTH+LOGDWIDTH),.OUT_DWIDTH(DWIDTH+LOGDWIDTH)) compute0_stage1(.A(compute0_out_stage2_reg),.B(compute1_out_stage2_reg),.OUT(compute0_out_stage1), .MODE(mode));
+
+  reduction_processing_element #(.IN_DWIDTH(DWIDTH+LOGDWIDTH),.OUT_DWIDTH(DWIDTH+LOGDWIDTH)) compute0_stage0(.A(outp),       .B(compute0_out_stage1_reg),     .OUT(compute0_out_stage0), .MODE(mode));
+
+endmodule
+///////////////////////////////////////////////////////
+//Rounding logic based on convergent rounding described 
+//here: https://zipcpu.com/dsp/2017/07/22/rounding.html
+///////////////////////////////////////////////////////
+module rounding( i_data, o_data );
+parameter IWID = 32;
+parameter OWID = 16;
+input  [IWID-1:0] i_data;
+output [OWID-1:0] o_data;
+
+wire [IWID-1:0] w_convergent;
+
+assign  w_convergent = i_data[(IWID-1):0]
+      + { {(OWID){1'b0}},
+        i_data[(IWID-OWID)],
+        {(IWID-OWID-1){!i_data[(IWID-OWID)]}}};
+
+assign o_data = w_convergent[(IWID-1):(IWID-OWID)];
+
+endmodule
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/reduction_unit.v
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/transpose.v
+//////////////////////////////////////////////////////////////////////
+module transpose #(
+  parameter WIDTH = 16,
+  parameter NUMSTAGES = 8,
+  parameter LOGNUMSTAGE = $clog2(NUMSTAGES)
+)(
+  input clk,
+  input resetn,
+  input en, 
+  input [NUMSTAGES * WIDTH -1:0] a,
+  output reg [NUMSTAGES * WIDTH -1:0] out,
+  output reg busy,
+  output reg valid
+);
+
+reg [NUMSTAGES * WIDTH - 1:0] data0;
+reg [NUMSTAGES * WIDTH - 1:0] data1;
+reg [NUMSTAGES * WIDTH - 1:0] data2;
+reg [NUMSTAGES * WIDTH - 1:0] data3;
+reg [NUMSTAGES * WIDTH - 1:0] data4;
+reg [NUMSTAGES * WIDTH - 1:0] data5;
+reg [NUMSTAGES * WIDTH - 1:0] data6;
+reg [NUMSTAGES * WIDTH - 1:0] data7;
+reg [LOGNUMSTAGE:0] count;
+
+always@(posedge clk)begin
+  if(!resetn)begin
+    count <= 'h0;
+    valid <= 'h0;
+  end
+  else begin
+    if(en)begin
+      count <= count + 1;
+      valid <= 0;
+    end
+    else if(count != 0)begin
+      valid <= 1'b1;
+      count <= count - 1;
+    end
+    else begin
+      count <= 0;
+      valid <= 0;
+    end
+  end
+end
+
+always@(posedge clk)begin
+  if(!resetn)
+     busy <= 1'b0;
+  else
+    if((count != 0) || (en == 1'b1))
+       busy <= 1'b1;
+    else
+       busy <= 1'b0; 
+end
+
+always @(posedge clk)begin
+  if(!resetn)begin
+    data0 <= 'h0;
+    data1 <= 'h0;
+    data2 <= 'h0;
+    data3 <= 'h0;
+    data4 <= 'h0;
+    data5 <= 'h0;
+    data6 <= 'h0;
+    data7 <= 'h0;
+    out <= 'h0;
+  end
+  else begin
+    out <= data0;
+    if(en)begin
+      case(count)
+      3'h0:begin
+               data0[0*WIDTH +: WIDTH] <= a[0*WIDTH +: WIDTH];
+               data1[0*WIDTH +: WIDTH] <= a[1*WIDTH +: WIDTH];
+               data2[0*WIDTH +: WIDTH] <= a[2*WIDTH +: WIDTH];
+               data3[0*WIDTH +: WIDTH] <= a[3*WIDTH +: WIDTH];
+               data4[0*WIDTH +: WIDTH] <= a[4*WIDTH +: WIDTH];
+               data5[0*WIDTH +: WIDTH] <= a[5*WIDTH +: WIDTH];
+               data6[0*WIDTH +: WIDTH] <= a[6*WIDTH +: WIDTH];
+               data7[0*WIDTH +: WIDTH] <= a[7*WIDTH +: WIDTH];
+           end
+      3'h1:begin
+               data0[1*WIDTH +: WIDTH] <= a[0*WIDTH +: WIDTH];
+               data1[1*WIDTH +: WIDTH] <= a[1*WIDTH +: WIDTH];
+               data2[1*WIDTH +: WIDTH] <= a[2*WIDTH +: WIDTH];
+               data3[1*WIDTH +: WIDTH] <= a[3*WIDTH +: WIDTH];
+               data4[1*WIDTH +: WIDTH] <= a[4*WIDTH +: WIDTH];
+               data5[1*WIDTH +: WIDTH] <= a[5*WIDTH +: WIDTH];
+               data6[1*WIDTH +: WIDTH] <= a[6*WIDTH +: WIDTH];
+               data7[1*WIDTH +: WIDTH] <= a[7*WIDTH +: WIDTH];
+           end
+      3'h2:begin
+               data0[2*WIDTH +: WIDTH] <= a[0*WIDTH +: WIDTH];
+               data1[2*WIDTH +: WIDTH] <= a[1*WIDTH +: WIDTH];
+               data2[2*WIDTH +: WIDTH] <= a[2*WIDTH +: WIDTH];
+               data3[2*WIDTH +: WIDTH] <= a[3*WIDTH +: WIDTH];
+               data4[2*WIDTH +: WIDTH] <= a[4*WIDTH +: WIDTH];
+               data5[2*WIDTH +: WIDTH] <= a[5*WIDTH +: WIDTH];
+               data6[2*WIDTH +: WIDTH] <= a[6*WIDTH +: WIDTH];
+               data7[2*WIDTH +: WIDTH] <= a[7*WIDTH +: WIDTH];
+           end
+      3'h3:begin
+               data0[3*WIDTH +: WIDTH] <= a[0*WIDTH +: WIDTH];
+               data1[3*WIDTH +: WIDTH] <= a[1*WIDTH +: WIDTH];
+               data2[3*WIDTH +: WIDTH] <= a[2*WIDTH +: WIDTH];
+               data3[3*WIDTH +: WIDTH] <= a[3*WIDTH +: WIDTH];
+               data4[3*WIDTH +: WIDTH] <= a[4*WIDTH +: WIDTH];
+               data5[3*WIDTH +: WIDTH] <= a[5*WIDTH +: WIDTH];
+               data6[3*WIDTH +: WIDTH] <= a[6*WIDTH +: WIDTH];
+               data7[3*WIDTH +: WIDTH] <= a[7*WIDTH +: WIDTH];
+           end
+      3'h4:begin
+               data0[4*WIDTH +: WIDTH] <= a[0*WIDTH +: WIDTH];
+               data1[4*WIDTH +: WIDTH] <= a[1*WIDTH +: WIDTH];
+               data2[4*WIDTH +: WIDTH] <= a[2*WIDTH +: WIDTH];
+               data3[4*WIDTH +: WIDTH] <= a[3*WIDTH +: WIDTH];
+               data4[4*WIDTH +: WIDTH] <= a[4*WIDTH +: WIDTH];
+               data5[4*WIDTH +: WIDTH] <= a[5*WIDTH +: WIDTH];
+               data6[4*WIDTH +: WIDTH] <= a[6*WIDTH +: WIDTH];
+               data7[4*WIDTH +: WIDTH] <= a[7*WIDTH +: WIDTH];
+           end
+      3'h5:begin
+               data0[5*WIDTH +: WIDTH] <= a[0*WIDTH +: WIDTH];
+               data1[5*WIDTH +: WIDTH] <= a[1*WIDTH +: WIDTH];
+               data2[5*WIDTH +: WIDTH] <= a[2*WIDTH +: WIDTH];
+               data3[5*WIDTH +: WIDTH] <= a[3*WIDTH +: WIDTH];
+               data4[5*WIDTH +: WIDTH] <= a[4*WIDTH +: WIDTH];
+               data5[5*WIDTH +: WIDTH] <= a[5*WIDTH +: WIDTH];
+               data6[5*WIDTH +: WIDTH] <= a[6*WIDTH +: WIDTH];
+               data7[5*WIDTH +: WIDTH] <= a[7*WIDTH +: WIDTH];
+           end
+      3'h6:begin
+               data0[6*WIDTH +: WIDTH] <= a[0*WIDTH +: WIDTH];
+               data1[6*WIDTH +: WIDTH] <= a[1*WIDTH +: WIDTH];
+               data2[6*WIDTH +: WIDTH] <= a[2*WIDTH +: WIDTH];
+               data3[6*WIDTH +: WIDTH] <= a[3*WIDTH +: WIDTH];
+               data4[6*WIDTH +: WIDTH] <= a[4*WIDTH +: WIDTH];
+               data5[6*WIDTH +: WIDTH] <= a[5*WIDTH +: WIDTH];
+               data6[6*WIDTH +: WIDTH] <= a[6*WIDTH +: WIDTH];
+               data7[6*WIDTH +: WIDTH] <= a[7*WIDTH +: WIDTH];
+           end
+      3'h7:begin
+               data0[7*WIDTH +: WIDTH] <= a[0*WIDTH +: WIDTH];
+               data1[7*WIDTH +: WIDTH] <= a[1*WIDTH +: WIDTH];
+               data2[7*WIDTH +: WIDTH] <= a[2*WIDTH +: WIDTH];
+               data3[7*WIDTH +: WIDTH] <= a[3*WIDTH +: WIDTH];
+               data4[7*WIDTH +: WIDTH] <= a[4*WIDTH +: WIDTH];
+               data5[7*WIDTH +: WIDTH] <= a[5*WIDTH +: WIDTH];
+               data6[7*WIDTH +: WIDTH] <= a[6*WIDTH +: WIDTH];
+               data7[7*WIDTH +: WIDTH] <= a[7*WIDTH +: WIDTH];
+           end
+      endcase
+    end
+    else if(valid)begin
+        data0 <= data1;
+        data1 <= data2;
+        data2 <= data3;
+        data3 <= data4;
+        data4 <= data5;
+        data5 <= data6;
+        data6 <= data7;
+        data7 <= 0;
+    end
+    
+  end  
+end
+
+endmodule
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/transpose.v
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/trp_unit.v
+//////////////////////////////////////////////////////////////////////
+module trp_unit #(parameter WIDTH=4)(
+ input clk,
+ input resetn,
+ input en,
+ input [8*WIDTH-1:0] a,
+ input [1:0] mode,
+ input read,
+ output busy,
+ output reg valid,
+ output reg[8*WIDTH-1:0] out
+);
+
+reg en_reduction;
+reg en_transpose;
+reg read_transpose;
+reg read_reduction;
+wire transpose_busy;
+wire reduction_busy;
+wire reduction_done;
+wire [8*WIDTH-1:0] reduction_out;
+wire [8*WIDTH-1:0] transpose_out;
+wire reduction_valid; 
+ 
+//assign busy = transpose_busy || reduction_busy;
+assign busy =  reduction_busy;
+
+always@(*)begin
+//  if(mode == 2'b11)begin
+//    en_transpose = en;
+//    en_reduction = 1'b0;
+//    read_transpose = read;
+//    read_reduction = 1'b0;
+//  end
+//  else begin
+//    en_transpose = 1'b0;
+    en_reduction = en;
+//    read_transpose = 1'b0;
+//    read_reduction = read;
+//  end
+end
+
+always@(*)begin
+ // if(transpose_busy)begin
+ //   out = transpose_out;
+ //   valid = 1'b1;
+ // end
+ // else if(reduction_done)begin
+    out = reduction_out;
+    valid = reduction_valid;
+ // end
+ // else begin
+ //   out = 'h0;
+ //   valid = 1'b0;
+ // end
+end
+
+reduction_layer #(
+  .DWIDTH(WIDTH)
+) u_reduction_layer(
+  .clk(clk),
+  .resetn(resetn),
+  .en(en_reduction),
+  .reduction_type(mode),
+  .a(a),
+  .reduced_out(reduction_out),
+  .done(reduction_done),
+  .busy(reduction_busy),
+  .valid(reduction_valid)
+);
+
+//transpose u_transpose(
+//  .clk(clk),
+//  .resetn(resetn),
+//  .read(),
+//  .en(en_transpose), 
+//  .a(a),
+//  .out(transpose_out),
+//  .busy(transpose_busy)
+//);
+
+endmodule
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/bfloat/trp_unit.v
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/dma.v
+//////////////////////////////////////////////////////////////////////
+module dma #(parameter NUMLANES=8,
+  parameter WIDTH = 16,
+  parameter ADDRWIDTH = 8,
+  parameter DMEM_WIDTH = NUMLANES * WIDTH,
+  parameter DMEM_ADDRWIDTH = 32,
+  parameter LOG2DMEMWIDTH= $clog2(DMEM_WIDTH)
+)(
+
+input clk,
+input resetn,
+
+input [DMEM_ADDRWIDTH-1:0] mem_addr,
+input [15:0] num_bytes,
+input dma_en,
+input [ADDRWIDTH-1:0] lane_addr,
+input we, // we = 1 means data from lane_addr will be transfered to main memory
+
+output reg [NUMLANES*ADDRWIDTH-1:0] local_addr,
+output reg [NUMLANES-1:0] local_wren,
+output reg [NUMLANES-1:0] local_rden,
+output reg [NUMLANES*WIDTH-1:0] local_wrdata,
+ input     [NUMLANES*WIDTH-1:0] local_rddata,
+
+output     dma_busy,
+output reg [DMEM_ADDRWIDTH-1:0]  dbus_address,
+ input  [DMEM_WIDTH-1:0]  dbus_readdata,
+output  [DMEM_WIDTH-1:0]   dbus_writedata,
+output reg [LOG2DMEMWIDTH-3-1:0]   dbus_byteen,
+output reg   dbus_en,
+output reg   dbus_wren,
+output reg   dbus_prefetch,
+ input    dbus_wait,   //Goes high 1-cycle after dbus_en
+ input    dbus_data_valid
+);
+
+parameter IDLE_STATE = 3'b000;
+parameter LOAD_REQ_STATE = 3'b001;
+parameter STORE_REQ_STATE = 3'b010;
+parameter READ_STATE = 3'b011;
+parameter LOAD_DATA_STATE = 3'b100;
+parameter WRITE_STATE = 3'b101;
+parameter UPDATE_RD_COUNT = 3'b110;
+parameter UPDATE_WR_COUNT = 3'b111;
+
+reg [15:0] count, next_count;
+reg [2:0] pstate,nstate;
+reg [NUMLANES*WIDTH-1:0] data_to_dbus, data_to_mem;
+reg[31:0]i,j,k;
+always@(posedge clk)begin
+  if(!resetn)begin
+    data_to_dbus <= 0;
+    data_to_mem <= 0;
+  end
+  else begin 
+    if(pstate == STORE_REQ_STATE)
+      data_to_dbus <= local_rddata;
+    if(pstate == LOAD_DATA_STATE)
+      for(j=0;j<DMEM_WIDTH/32;j=j+1)
+        for(k=0;k<2;k=k+1)
+          data_to_mem[(1-k)*16+j*32+:16] <= dbus_readdata[k*16+j*32+:16]; 
+  end
+end
+
+assign dbus_writedata = (pstate == STORE_REQ_STATE)? local_rddata : data_to_dbus;
+
+always@(posedge clk )begin
+  if(!resetn)begin
+    count <= 0;
+    pstate <= IDLE_STATE;
+  end 
+  else begin
+    count <= next_count;
+    pstate <= nstate;
+  end 
+end
+
+assign dma_busy = (pstate == IDLE_STATE)? 1'b0:1'b1; 
+
+always@(*)begin
+  case(pstate)
+    IDLE_STATE:begin
+                 if((!we) & dma_en )        
+                   nstate  = LOAD_REQ_STATE;
+                 else  if(we & dma_en)
+                   nstate = STORE_REQ_STATE;
+                 else
+                   nstate = IDLE_STATE;
+               end
+    LOAD_REQ_STATE:begin
+                     if(count != num_bytes)
+                       nstate = READ_STATE;
+                     else
+                       nstate = IDLE_STATE;
+                   end
+    STORE_REQ_STATE:begin
+                     if(count != num_bytes)
+                       nstate = WRITE_STATE;
+                     else
+                       nstate = IDLE_STATE;
+                   end
+    READ_STATE:begin
+                 if(!dbus_wait)
+                   nstate = LOAD_DATA_STATE;
+                 else
+                   nstate = READ_STATE;
+               end
+    LOAD_DATA_STATE:begin
+                        nstate = UPDATE_RD_COUNT;
+                    end
+    WRITE_STATE:begin
+                 if(dbus_wait)
+                   nstate = WRITE_STATE;
+                 else
+                   nstate = UPDATE_WR_COUNT;
+               end
+    UPDATE_WR_COUNT:begin
+                        nstate = STORE_REQ_STATE;
+                    end
+    UPDATE_RD_COUNT:begin
+                        nstate = LOAD_REQ_STATE;
+                    end
+  endcase
+end
+
+always@(*)begin
+  dbus_prefetch = 0;
+  case(pstate)
+    IDLE_STATE: begin
+                   dbus_address =0;
+                   dbus_byteen = 0;
+                   dbus_en = 0; 
+                   dbus_wren = 0;
+                   next_count = 0;
+                   local_wren = 0;
+                   local_rden = 0;
+                end 
+    LOAD_REQ_STATE:begin
+                     dbus_address = mem_addr + count;
+                     dbus_byteen = 0;
+                     dbus_en = 1; 
+                     dbus_wren = 0;
+                     next_count = count;
+                   end
+    STORE_REQ_STATE:begin
+                     for(i=0; i<NUMLANES;i=i+1)begin
+                       local_addr[i*ADDRWIDTH +: ADDRWIDTH] =  lane_addr  + count + i;
+                       local_wren[i] = 1'b0;
+                       local_rden[i] = 1'b1;
+                     end
+                     dbus_address = mem_addr + count;
+                     dbus_byteen = 16'hffff;
+                     dbus_en = 1; 
+                     dbus_wren = 1;
+                     next_count = count ;
+                   end
+    READ_STATE:begin
+                     dbus_byteen = 0;
+                     dbus_en = 0; 
+                     dbus_wren = 0;
+                     next_count = count;
+               end
+    LOAD_DATA_STATE:begin
+                     dbus_byteen = 0;
+                     dbus_en = 0; 
+                     dbus_wren = 0;
+                     next_count = count;
+                    end
+    WRITE_STATE:begin
+                       dbus_address = mem_addr + count;
+                       dbus_byteen = {NUMLANES{2'b11}};
+                       dbus_en = 0; 
+                       dbus_wren = 0;
+                       next_count = count;
+               end
+    UPDATE_WR_COUNT:begin
+                       dbus_address = mem_addr + count;
+                       dbus_byteen = {NUMLANES{2'b11}};
+                       dbus_en = 0; 
+                       dbus_wren = 0;
+                       next_count = count;
+                       next_count = count + (NUMLANES*WIDTH/8);
+                     end
+    UPDATE_RD_COUNT: begin
+                       for(i=0; i<NUMLANES;i=i+1)begin
+                         local_addr[i*ADDRWIDTH +: ADDRWIDTH] =  lane_addr  + count + i;
+                         local_wren[i] = 1'b1;
+                         local_rden[i] = 1'b0;
+                       end
+                       local_wrdata = data_to_mem; 
+                       dbus_address = mem_addr + count;
+                       dbus_byteen = {NUMLANES{2'b00}};
+                       dbus_en = 0; 
+                       dbus_wren = 0;
+                       next_count = count + (NUMLANES*WIDTH/8);
+                end
+  endcase
+end
+
+endmodule
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/dma.v
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vmem_local.v
+//////////////////////////////////////////////////////////////////////
+module vmem_local (
+clk,
+resetn,
+en,
+
+op,
+address_a,
+stride_val_a,
+offset_a,
+data_a,
+out_a,
+last_subvector,
+
+address_b,
+rden_b,
+wren_b,
+data_b,
+out_b
+);
+
+
+parameter NUMLANES = 8;
+parameter DATAWORDSIZE = 16;
+parameter VCWIDTH = 32;  
+parameter MEMDEPTH = 2048; 
+parameter LOGMEMDEPTH = $clog2(MEMDEPTH);
+
+parameter MEM_IDLE = 1'b0;
+parameter MEM_STRIDE = 1'b1;
+
+input clk;
+input resetn;
+input [LOGMEMDEPTH-1:0] address_a;
+input [NUMLANES*LOGMEMDEPTH-1:0] address_b;
+input en;
+input [6:0] op;
+input rden_b;
+input wren_b;
+input last_subvector;
+input [NUMLANES*DATAWORDSIZE-1:0] data_a;
+input [NUMLANES*DATAWORDSIZE-1:0] data_b;
+output [NUMLANES*DATAWORDSIZE-1:0] out_a;
+output [NUMLANES*DATAWORDSIZE-1:0] out_b;
+input [VCWIDTH-1:0] stride_val_a;
+input [NUMLANES*16-1:0] offset_a;
+
+wire stride_req_a;
+wire [VCWIDTH-1:0] stride;
+wire index_req_a;
+reg wren_a,rden_a; 
+reg req_we_a;
+reg req_we_b;
+reg [NUMLANES*LOGMEMDEPTH-1:0] reg_address_a;
+reg [NUMLANES*LOGMEMDEPTH-1:0] reg_address_b;
+
+wire  [1:0]  op_pattern;       // 0-Unit, 1-Strided, 2-Indexed
+wire  [1:0]  op_size;          // 0-byte, 1-16bits, 2-32bits, 3-64bits
+wire         op_signed;        // 0-unsigned, 1-signed
+wire         op_we;            // 0-load, 1-store
+wire         op_memop;         // 1-memory op, 0-vector shift op
+genvar  g_mem;
+reg [31:0] i;
+
+reg [NUMLANES-1:0] g_en;
+
+assign {op_memop,op_pattern,op_size,op_signed,op_we}=op;
+//assign rden_a = (op_memop & (~op_we))? 1'b1:1'b0;
+//assign wren_a = (op_memop & op_we)? 1'b1:1'b0;
+assign stride = (op_pattern == 2'b01)? stride_val_a: 1;
+assign stride_req_a = (~op_pattern[1] & op_memop)? 1'b1:1'b0;
+assign index_req_a =  (op_pattern[1] & op_memop)? 1'b1: 1'b0;
+
+//Lane 0 Memory address space : 0,8,16,24,...,(MEMDEPTH*8-1)
+//Lane 1 Memory address space : 0+1,8+1,16+1,24+1,...,(MEMDEPTH*8-1+1)
+
+reg last_subvector_q;
+
+always@(posedge clk)begin 
+  if(!resetn)
+    last_subvector_q <= 1'b0;
+  else
+    last_subvector_q <= last_subvector;
+end
+
+wire mem_op_valid;
+assign mem_op_valid = ~(last_subvector & last_subvector_q); 
+
+always@(*)begin
+  if(op_memop & (~op_we))
+    rden_a = 1'b1;
+  else
+    rden_a = 1'b0;
+
+  if(op_memop & op_we & mem_op_valid)
+    wren_a = 1'b1;
+  else
+    wren_a = 1'b0;
+
+  for(i=0; i< NUMLANES; i=i+1)begin
+    if(i[2:0] == address_a[2:0])
+      g_en[i] = 1'b1;
+    else
+      g_en[i] = 1'b0;
+    
+    reg_address_a[i*LOGMEMDEPTH +: LOGMEMDEPTH] = address_a + i * stride;
+    reg_address_b[i*LOGMEMDEPTH +: LOGMEMDEPTH] = address_b[i*LOGMEMDEPTH +: LOGMEMDEPTH];
+    if(index_req_a)begin
+        reg_address_a[i*LOGMEMDEPTH +: LOGMEMDEPTH] = address_a + offset_a[i*16+:16];
+    end
+  end
+end
+
+generate 
+    for(g_mem =0; g_mem < NUMLANES ; g_mem = g_mem+1 )begin:gen_memperlane
+        per_lane_mem_wrapper #(.AWIDTH(LOGMEMDEPTH),.NUM_WORDS(MEMDEPTH), .DWIDTH(DATAWORDSIZE)) inst_mem(
+      .clk(clk),
+            .resetn(resetn),
+      .address_a(reg_address_a[g_mem*LOGMEMDEPTH +: LOGMEMDEPTH]),
+      .address_b(reg_address_b[g_mem*LOGMEMDEPTH +: LOGMEMDEPTH]),
+            .rden_a(rden_a & en),
+            .rden_b(rden_b),
+      .wren_a(wren_a & en),
+      .wren_b(wren_b),
+      .data_a(data_a[g_mem*DATAWORDSIZE +: DATAWORDSIZE]),
+      .data_b(data_b[g_mem*DATAWORDSIZE +: DATAWORDSIZE]),
+      .out_a(out_a[g_mem*DATAWORDSIZE +: DATAWORDSIZE]),
+      .out_b(out_b[g_mem*DATAWORDSIZE +: DATAWORDSIZE])
+      //.out_b()
+        );
+    end
+endgenerate
+
+endmodule
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/vmem_local.v
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/dma_axi_mux.v
+//////////////////////////////////////////////////////////////////////
+module dma_axi_mux #(
+  parameter ADDRWIDTH = 11,
+  parameter NUMLANES = 8,
+  parameter WIDTH = 16
+)(
+  input [NUMLANES*ADDRWIDTH-1:0]   dma_addr,
+  input [NUMLANES*WIDTH-1:0]       dma_data,
+  input [NUMLANES-1:0]             dma_rden,
+  input  [NUMLANES-1:0]            dma_wren,    
+  
+  output reg [NUMLANES*WIDTH-1:0]  dma_out,   
+ 
+  input [ADDRWIDTH-1:0]            axi_addr,   
+  input [NUMLANES*WIDTH-1:0]       axi_data,    
+  input                            axi_req_en,  
+  input                            axi_req_type,
+  
+  output reg [NUMLANES*WIDTH-1:0]  axi_read_data,
+  
+  output reg [NUMLANES*ADDRWIDTH-1:0]       mem_addr,    
+  output reg [NUMLANES*WIDTH-1:0]  mem_data,     
+  output reg [NUMLANES-1:0]        mem_rden,     
+  output reg [NUMLANES-1:0]        mem_wren,     
+  input [NUMLANES*WIDTH-1:0]  mem_readdata    
+);
+
+reg [NUMLANES-1:0] axi_rden, axi_wren;
+reg [NUMLANES*ADDRWIDTH-1:0] axi_lane_addr;
+
+always@(*)begin
+  axi_lane_addr[(1*ADDRWIDTH)-1 : 0*ADDRWIDTH ] = axi_addr + 11'h0;
+  axi_lane_addr[2*ADDRWIDTH-1:1*ADDRWIDTH] = axi_addr + 11'h1;
+  axi_lane_addr[3*ADDRWIDTH-1:2*ADDRWIDTH] = axi_addr + 11'h2;
+  axi_lane_addr[4*ADDRWIDTH-1:3*ADDRWIDTH] = axi_addr + 11'h3;
+  axi_lane_addr[5*ADDRWIDTH-1:4*ADDRWIDTH] = axi_addr + 11'h4;
+  axi_lane_addr[6*ADDRWIDTH-1:5*ADDRWIDTH] = axi_addr + 11'h5;
+  axi_lane_addr[7*ADDRWIDTH-1:6*ADDRWIDTH] = axi_addr + 11'h6;
+  axi_lane_addr[8*ADDRWIDTH-1:7*ADDRWIDTH] = axi_addr + 11'h7;
+end
+
+always@(*)begin
+  axi_rden = 0;
+  axi_wren = 0;
+  if(axi_req_en)begin
+    if(axi_req_type)begin
+      axi_wren = {NUMLANES{1'b1}};
+    end
+    else begin
+      axi_rden = {NUMLANES{1'b1}};
+    end
+  end
+end
+
+always@(*)begin
+   if(axi_req_en)begin
+     mem_addr = axi_lane_addr;
+     mem_data = axi_data;
+     mem_rden = axi_rden;
+     mem_wren = axi_wren;
+     dma_out  = mem_readdata;
+     axi_read_data = 0;
+   end
+   else begin
+     mem_addr = dma_addr; 
+     mem_data = dma_data;
+     mem_rden = dma_rden;
+     mem_wren = dma_wren;
+     dma_out  = mem_readdata;
+     axi_read_data = 0;
+   end
+end
+endmodule
+
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector/dma_axi_mux.v
+//////////////////////////////////////////////////////////////////////
+
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/interface/axi4_slave.v
+//////////////////////////////////////////////////////////////////////
+module axi4_slave #
+(
+    
+    parameter integer P_ADDR_WIDTH   = 16,                                      //Width of Address Bus
+    parameter integer P_DATA_WIDTH   = 128                                      //Width of Data Bus
+)
+(
+    output  reg [P_ADDR_WIDTH - 1:0] req_addr,
+    output  reg [P_DATA_WIDTH - 1:0] req_data,
+    output  reg req_en,
+    output  reg     req_type,
+    output axi_busy,
+    input   [P_DATA_WIDTH - 1:0]     req_read_data,
+
+    input  wire CLOCK,                                                          //Global Clock Signal.
+    input  wire RESET,                                                          //Global Reset Signal. This Signal is Active Low
+
+    input wire [6 - 1:0] AWID,                                        //Master Interface Write Address ID
+    input wire [P_ADDR_WIDTH - 1:0] AWADDR,                                    //Master Interface Write Address
+    input wire [7:0] AWLEN,                                                    //Burst length. The burst length gives the exact number of transfers in a burst
+    input wire [2:0] AWSIZE,                                                   //Burst size. This signal indicates the size of each transfer in the burst
+    input wire [1:0] AWBURST,                                                  //Burst type. The burst type and the size information, determine how the address for each transfer within the burst is calculated.
+    input wire AWLOCK,                                                         //Lock type. Provides additional information about the atomic characteristics of the transfer.
+    input wire [3:0] AWCACHE,                                                  //Memory type. This signal indicates how transactions are required to progress through a system.
+    input wire [2:0] AWPROT,                                                   //Protection type. This signal indicates the privilege and security level of the transaction, and whether  the transaction is a data access or an instruction access.
+    input wire [3:0] AWQOS,                                                    //Quality of Service, QoS identifier sent for each write transaction.
+    input wire AWVALID,                                                        //Write address valid. This signal indicates that the channel is signaling valid write address and control information.
+    output  wire AWREADY,                                                        //Write address ready. This signal indicates that the slave is ready to accept an address and associated control signals
+    input wire [P_DATA_WIDTH-1 : 0] WDATA,                                     //Master Interface Write Data.
+    input wire [P_DATA_WIDTH/8-1 : 0] WSTRB,                                   //Write strobes. This signal indicates which byte lanes hold valid data. There is one write strobe bit for each eight bits of the write data bus.
+    input wire WLAST,                                                          //Write last. This signal indicates the last transfer in a write burst.
+    input wire WVALID,                                                         //Write valid. This signal indicates that valid write data and strobes are available
+    output  wire WREADY,                                                         //Write ready. This signal indicates that the slave can accept the write data.
+
+    input wire [6-1 : 0] ARID,                                        //Master Interface Read Address.
+    input wire [P_ADDR_WIDTH-1 : 0] ARADDR,                                    //Read address. This signal indicates the initial address of a read burst transaction.
+    input wire [7 : 0] ARLEN,                                                  //Burst length. The burst length gives the exact number of transfers in a burst
+    input wire [2 : 0] ARSIZE,                                                 //Burst size. This signal indicates the size of each transfer in the burst
+    input wire [1 : 0] ARBURST,                                                //Burst type. The burst type and the size information, determine how the address for each transfer within the burst is calculated.
+    input wire ARLOCK,                                                         //Lock type. Provides additional information about the atomic characteristics of the transfer.
+    input wire [3 : 0] ARCACHE,                                                //Memory type. This signal indicates how transactions are required to progress through a system.
+    input wire [2 : 0] ARPROT,                                                 //Protection type. This signal indicates the privilege and security level of the transaction, and whether the transaction is a data access or an instruction access.
+    input wire [3 : 0] ARQOS,                                                  //Quality of Service, QoS identifier sent for each read transaction
+    input wire ARVALID,                                                        //Write address valid. This signal indicates that the channel is signaling valid read address and control information
+    output  wire ARREADY,                                                        //Read address ready. This signal indicates that the slave is ready to accept an address and associated control signals
+    output  wire [6-1 : 0] RID,                                         //Read ID tag. This signal is the identification tag for the read data group of signals generated by the slave.
+    output  wire [P_DATA_WIDTH-1 : 0] RDATA,                                     //Master Read Data
+    output  wire [1 : 0] RRESP,                                                  //Read response. This signal indicates the status of the read transfer
+    output  wire RLAST,                                                          //Read last. This signal indicates the last transfer in a read burst
+    output  wire RVALID,                                                         //Read valid. This signal indicates that the channel is signaling the required read data.
+    input wire RREADY,                                                         //Read ready. This signal indicates that the master can accept the read data and response information.
+
+    input wire BREADY,                                                         //Response ready. This signal indicates that the master can accept a write response.
+    output  wire BVALID,                                                         //Write response valid. This signal indicates that the channel is signaling a valid write response.
+    output  wire [1 : 0] BRESP,                                                  //Write response. This signal indicates the status of the write transaction.
+    output  wire [6-1 : 0] BID                                          //Master Interface Write Response.
+);
+
+localparam integer C_MASTER_LENGTH = 12;
+
+reg [2:0] slave_state;
+localparam [2:0] IDLE = 0;
+localparam [2:0] RDREQ_STATE  = 1;
+localparam [2:0] WRREQ_STATE  = 2;
+localparam [2:0] WRDATA_STATE = 3;
+localparam [2:0] RDATA_STATE = 4;
+
+reg [P_ADDR_WIDTH - 1:0] q_req_addr;
+
+//AXI4 internal tmp signals
+reg [6 - 1:0]   s_rid = 0;
+wire [P_DATA_WIDTH - 1:0] s_rdata;
+reg s_rlast;
+reg s_rvalid;
+
+reg s_bvalid;                                                         //Write response valid. This signal indicates that the channel is signaling a valid write response.
+                                           //Master Interface Write Response.
+reg [31:0] m_writer_counter = 0;
+reg [2:0] count;
+reg q_wrreq_valid;
+
+
+wire s_awready;
+wire s_arready;
+wire s_wready;
+
+assign AWREADY = s_awready;
+assign WREADY = s_wready;
+assign ARREADY = s_arready;
+
+assign RID = 0;                                         //Read ID tag. This signal is the identification tag for the read data group of signals generated by the slave.
+assign RDATA = s_rdata;                                     //Master Read Data
+assign RRESP = 0;                                                  //Read response. This signal indicates the status of the read transfer
+assign RLAST = s_rlast;                                                          //Read last. This signal indicates the last transfer in a read burst
+assign RVALID = s_rvalid;                                                        //Read ready. This signal indicates that the master can accept the read data and response information.
+
+assign BID = 0;
+assign BRESP = 0;
+assign BVALID = s_bvalid;
+
+//Read and Read Response (R)
+//assign RREADY = m_rready;
+
+//Write Address Channel
+//Write Data Generator.Data pattern is only a simple incrementing count from 0 for each burst.
+//always @(posedge CLOCK) begin
+//    if (RESET == 0) begin
+//        s_rdata <= 0;
+//    end else if (((slave_state == IDLE) & (ARVALID))|(slave_state == RDATA_STATE)) begin
+//        s_rdata <= req_read_data;
+//    end else  begin
+//        s_rdata <= 0;
+//    end
+//end
+
+assign s_rdata = req_read_data;
+assign s_awready = 1'b1;
+assign s_arready = 1'b1;
+assign s_wready = 1'b1;
+
+//Write Response (B) Channel
+
+//Need this to silent VIP warning
+always @(posedge CLOCK) begin
+    if (RESET == 0) begin
+        s_bvalid <= 0;
+    end
+    else if((slave_state == WRDATA_STATE))begin
+        s_bvalid <= 1'b1;
+    end
+    else begin
+        s_bvalid <= 0;
+    end
+end
+
+always @(posedge CLOCK)begin
+  if(!RESET)begin
+    s_rvalid <= 0;
+  end else begin
+     if((slave_state == IDLE) & ARVALID)
+       s_rvalid <= 1'b1;
+     else if((slave_state == RDATA_STATE) & (count==7))
+       s_rvalid <= 1'b0;
+     else
+       s_rvalid <= s_rvalid;
+  end
+end
+
+always @(posedge CLOCK) begin
+    if (RESET == 0) begin
+        s_rlast <= 0;
+    end
+    else if((slave_state == RDATA_STATE) & (count == 7))begin
+        s_rlast <= 1'b1;
+    end
+    else begin
+        s_rlast <=1'b0;
+    end
+end
+
+always@(posedge CLOCK)begin
+  if(!RESET)begin
+    q_req_addr <= 0;
+  end else begin
+     if (slave_state == WRDATA_STATE)
+        q_req_addr <= q_req_addr + 16;
+     else if(slave_state == RDATA_STATE)
+        q_req_addr <= q_req_addr + 16;
+     else if(AWVALID)
+        q_req_addr <= AWADDR;
+     else if(ARVALID)
+        q_req_addr <= ARADDR;
+    
+    
+  end
+end
+
+always@(posedge CLOCK)begin
+  if(!RESET)begin
+    q_wrreq_valid <= 1'b0;
+  end
+  else begin
+    q_wrreq_valid <= AWVALID; 
+  end
+end
+
+
+always@(*) begin
+  if(slave_state == IDLE)begin
+     if(ARVALID)begin
+        req_type = 1'b0;
+        req_addr = ARADDR;
+        req_data = 0;
+     end
+     if(q_wrreq_valid)begin
+        req_type = 1'b1;
+        req_addr = q_req_addr;
+        req_data = 0;
+     end
+     else begin
+        req_type = 1'b0;
+        req_addr = 0;
+        req_data = 0;  
+     end
+  end
+  if(slave_state == WRDATA_STATE)begin
+    req_type = 1'b1;
+    req_addr = q_req_addr;  
+    req_data = WDATA;
+  end
+  else if(slave_state == RDATA_STATE)begin
+    req_type = 1'b0;
+    req_addr = q_req_addr;
+    req_data = 0;
+  end
+  else begin
+    req_type = 1'b0;
+    req_addr = 0;
+    req_data = 0;
+  end        
+end
+
+always@(*)begin
+  if(slave_state == WRDATA_STATE || slave_state == RDATA_STATE)
+  req_en = 1'b1;
+  else
+        req_en = 1'b0;
+end
+
+assign axi_busy = (slave_state == IDLE)? 1'b1:1'b0;
+
+//implement master command interface state machine
+always @ (posedge CLOCK) begin
+    if (RESET == 0) begin
+        count <= 0;
+        slave_state <= IDLE;
+    end else begin
+        case (slave_state)
+            IDLE: begin
+                if (AWVALID) begin
+                    slave_state <= WRDATA_STATE;
+                end
+                else if(ARVALID) begin
+                    slave_state <= RDATA_STATE;
+                end
+                count <= 0;
+            end
+            WRREQ_STATE: begin
+                if (WVALID)
+                    slave_state <= WRDATA_STATE;
+                else 
+                    slave_state <= WRREQ_STATE;
+            end
+            WRDATA_STATE: begin
+                if ((count == 7) & WREADY & WVALID) begin
+                    slave_state <= IDLE;
+                end else begin
+                    count <= count + 1;
+                end 
+            end
+            RDREQ_STATE: begin
+                if (RVALID)
+                    slave_state <= RDATA_STATE;
+                else 
+                    slave_state <= RDREQ_STATE;
+            end
+            RDATA_STATE: begin
+                if ((count == 7) & RREADY & RREADY) begin
+                    slave_state <= IDLE;
+                end else
+                    count <= count + 1;
+            end
+            default: begin
+                slave_state <= IDLE;
+            end
+        endcase
+    end
+end
+
+
+endmodule
+
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/interface/axi4_slave.v
+//////////////////////////////////////////////////////////////////////
+
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/interface/axi4_master.v
+//////////////////////////////////////////////////////////////////////
+
+module axi4_master #
+(
+    parameter P_TARGET_SLAVE_BASE_ADDR     = 32'h0,                             //Base address of targeted slave
+    
+    parameter integer P_ADDR_WIDTH   = 32,                                      //Width of Address Bus
+    parameter integer P_DATA_WIDTH   = 128                                      //Width of Data Bus
+)
+(
+    input  wire [P_ADDR_WIDTH - 1:0] req_addr,
+    input  wire [P_DATA_WIDTH - 1:0] req_data,
+    input  wire req_en,
+    input       req_type,
+    output reg [P_DATA_WIDTH - 1:0]     req_read_data,
+    output      axi_busy,
+    input [7:0] in_dst,
+    input   in_dst_we,
+    input [7:0]  in_dst_mask, 
+
+    output [7:0] out_dst,
+    output   out_dst_we,
+    output [7:0]  out_dst_mask, 
+
+    input  wire CLOCK,                                                          //Global Clock Signal.
+    input  wire RESET,                                                          //Global Reset Signal. This Signal is Active Low
+
+    output wire [6 - 1:0] AWID,                                        //Master Interface Write Address ID
+    output wire [P_ADDR_WIDTH - 1:0] AWADDR,                                    //Master Interface Write Address
+    output wire [7:0] AWLEN,                                                    //Burst length. The burst length gives the exact number of transfers in a burst
+    output wire [2:0] AWSIZE,                                                   //Burst size. This signal indicates the size of each transfer in the burst
+    output wire [1:0] AWBURST,                                                  //Burst type. The burst type and the size information, determine how the address for each transfer within the burst is calculated.
+    output wire AWLOCK,                                                         //Lock type. Provides additional information about the atomic characteristics of the transfer.
+    output wire [3:0] AWCACHE,                                                  //Memory type. This signal indicates how transactions are required to progress through a system.
+    output wire [2:0] AWPROT,                                                   //Protection type. This signal indicates the privilege and security level of the transaction, and whether  the transaction is a data access or an instruction access.
+    output wire [3:0] AWQOS,                                                    //Quality of Service, QoS identifier sent for each write transaction.
+    output wire AWVALID,                                                        //Write address valid. This signal indicates that the channel is signaling valid write address and control information.
+    input  wire AWREADY,                                                        //Write address ready. This signal indicates that the slave is ready to accept an address and associated control signals
+    output wire [P_DATA_WIDTH-1 : 0] WDATA,                                     //Master Interface Write Data.
+    output wire [P_DATA_WIDTH/8-1 : 0] WSTRB,                                   //Write strobes. This signal indicates which byte lanes hold valid data. There is one write strobe bit for each eight bits of the write data bus.
+    output wire WLAST,                                                          //Write last. This signal indicates the last transfer in a write burst.
+    output wire WVALID,                                                         //Write valid. This signal indicates that valid write data and strobes are available
+    input  wire WREADY,                                                         //Write ready. This signal indicates that the slave can accept the write data.
+
+    output wire [6-1 : 0] ARID,                                        //Master Interface Read Address.
+    output wire [P_ADDR_WIDTH-1 : 0] ARADDR,                                    //Read address. This signal indicates the initial address of a read burst transaction.
+    output wire [7 : 0] ARLEN,                                                  //Burst length. The burst length gives the exact number of transfers in a burst
+    output wire [2 : 0] ARSIZE,                                                 //Burst size. This signal indicates the size of each transfer in the burst
+    output wire [1 : 0] ARBURST,                                                //Burst type. The burst type and the size information, determine how the address for each transfer within the burst is calculated.
+    output wire ARLOCK,                                                         //Lock type. Provides additional information about the atomic characteristics of the transfer.
+    output wire [3 : 0] ARCACHE,                                                //Memory type. This signal indicates how transactions are required to progress through a system.
+    output wire [2 : 0] ARPROT,                                                 //Protection type. This signal indicates the privilege and security level of the transaction, and whether the transaction is a data access or an instruction access.
+    output wire [3 : 0] ARQOS,                                                  //Quality of Service, QoS identifier sent for each read transaction
+    output wire ARVALID,                                                        //Write address valid. This signal indicates that the channel is signaling valid read address and control information
+    input  wire ARREADY,                                                        //Read address ready. This signal indicates that the slave is ready to accept an address and associated control signals
+    input  wire [6-1 : 0] RID,                                         //Read ID tag. This signal is the identification tag for the read data group of signals generated by the slave.
+    input  wire [P_DATA_WIDTH-1 : 0] RDATA,                                     //Master Read Data
+    input  wire [1 : 0] RRESP,                                                  //Read response. This signal indicates the status of the read transfer
+    input  wire RLAST,                                                          //Read last. This signal indicates the last transfer in a read burst
+    input  wire RVALID,                                                         //Read valid. This signal indicates that the channel is signaling the required read data.
+    output wire RREADY,                                                         //Read ready. This signal indicates that the master can accept the read data and response information.
+
+    output wire BREADY,                                                         //Response ready. This signal indicates that the master can accept a write response.
+    input  wire BVALID,                                                         //Write response valid. This signal indicates that the channel is signaling a valid write response.
+    input  wire [1 : 0] BRESP,                                                  //Write response. This signal indicates the status of the write transaction.
+    input  wire [6-1 : 0] BID                                          //Master Interface Write Response.
+);
+
+//Function called clogb2 that returns an integer which has the value of the
+//ceiling of the log base 2
+////function integer clogb2 (input integer bit_depth);
+////begin
+////    for(clogb2=0; bit_depth>0; clogb2=clogb2+1)
+////        bit_depth = bit_depth >> 1;
+////    end
+////endfunction
+//
+////P_WRITE_TRANSACTIONS_NUM is the width of the index counter for number of
+//write or read transaction.
+////localparam integer P_WRITE_TRANSACTIONS_NUM = clogb2(P_WRITE_BURSTS - 1);
+//
+////Burst length for transactions, in P_DATA_WIDTHs. Non-2^n lengths will
+//eventually cause bursts across 4K address boundaries.
+//localparam integer C_MASTER_LENGTH = 12;
+//
+////Total number of burst transfers is master length divided by burst length
+//and burst size
+localparam integer C_NO_BURSTS_REQ = 12;
+
+//= C_MASTER_LENGTH-clogb2((P_WRITE_BURSTS*P_DATA_WIDTH/8)-1);
+//
+//// Example State machine to initialize counter, initialize write
+//transactions, initialize read transactions and comparison of read data with
+//the written data words.
+
+//Total number of burst transfers is master length divided by burst length and burst size
+//localparam integer C_NO_BURSTS_REQ = C_MASTER_LENGTH-clogb2((P_WRITE_BURSTS*P_DATA_WIDTH/8)-1);
+
+// Example State machine to initialize counter, initialize write transactions, initialize read transactions and comparison of read data with the written data words.
+reg [1:0] master_state;
+localparam [1:0] IDLE = 0;
+localparam [1:0] REQ_STATE  = 1;
+localparam [1:0] WRDATA_STATE = 2;
+localparam [1:0] RDATA_STATE = 3;
+
+//reg [P_ADDR_WIDTH - 1:0] m_write_addr = 0;
+//reg [P_DATA_WIDTH - 1:0] m_write_data = 0;
+//reg [6 - 1:0]   m_write_awid = 0;
+
+//AXI4 internal tmp signals
+reg [6 - 1:0]   m_awid = 0;
+reg [P_ADDR_WIDTH - 1:0] m_awaddr;
+reg m_awvalid;
+reg [P_DATA_WIDTH - 1:0] m_wdata;
+reg m_wlast;
+reg m_wvalid;
+reg m_bready;
+reg [P_ADDR_WIDTH - 1:0] m_araddr;
+reg m_arvalid;
+reg m_rready;
+reg [P_ADDR_WIDTH - 1:0] q_req_addr;
+reg [P_DATA_WIDTH - 1:0] q_req_data;
+reg [P_DATA_WIDTH - 1:0] q2_req_data;
+reg q_req_type;
+reg [2:0] count;
+//reg [P_WRITE_TRANSACTIONS_NUM:0] write_index;                                   //write beat count in a burst
+//reg [P_WRITE_TRANSACTIONS_NUM:0] read_index;                                    //read beat count in a burst
+//wire [P_WRITE_TRANSACTIONS_NUM + 2: 0] burst_size_bytes;                        //size of P_WRITE_BURSTS length burst in bytes
+
+//The burst counters are used to track the number of burst transfers of 
+//P_WRITE_BURSTS burst length needed to transfer 2^C_MASTER_LENGTH bytes of data.
+//reg [C_NO_BURSTS_REQ : 0] write_burst_counter;
+//reg [C_NO_BURSTS_REQ : 0] read_burst_counter;
+// reg start_single_burst_write;
+// reg start_single_burst_read;
+// reg writes_done;
+// reg reads_done;
+// reg error_reg;
+reg compare_done;
+//reg read_mismatch;
+//reg burst_write_active;
+//reg burst_read_active;
+//reg [P_DATA_WIDTH - 1: 0] expected_rdata;
+
+//Interface response error flags
+//wire write_resp_error;
+//wire read_resp_error;
+//wire wnext;
+//wire rnext;
+//reg  init_txn_ff;
+//reg  init_txn_ff2;
+//reg  init_txn_edge;
+//wire init_txn_pulse;
+
+reg [31:0] m_writer_counter = 0;
+
+// I/O Connections assignments
+//assign WRITE_READY = ((AWREADY && WREADY) || current_state == IDLE) ? 1 : 0;
+//assign WRITE_READY = (AWREADY && WREADY) ? 1 : 0;
+
+//Write Address (AW)
+assign AWID = m_awid + m_writer_counter;
+assign AWADDR = P_TARGET_SLAVE_BASE_ADDR + m_awaddr;                            //The AXI address is a concatenation of the target base address + active offset range
+assign AWLEN= 8'h0;                                               //Burst LENgth is number of transaction beats, minus 1
+assign AWSIZE = 3'b100;                                 //Size should be P_DATA_WIDTH, in 2^SIZE bytes, otherwise narrow bursts are used
+assign AWBURST = 2'b01;                                                         //INCR burst type is usually used, except for keyhole bursts
+assign AWCACHE = 4'b1100;
+assign AWPROT = 3'h0;
+assign AWQOS = 4'h0;
+assign AWVALID = m_awvalid;
+assign AWLOCK = 1'b0;                                                           //Update value to 4'b0011 if coherent accesses to be used via the Zynq ACP port.
+                                                                                //Not Allocated, Modifiable, not Bufferable. Not Bufferable since this example is meant to test memory, not intermediate cache.
+//Write Data(W)
+assign WDATA = m_wdata;                                                         //All bursts are complete and aligned in this example
+assign WSTRB = {(P_DATA_WIDTH / 8){1'b1}};
+assign WLAST = m_wlast;
+assign WVALID = m_wvalid;
+
+//Write Response (B)
+assign BREADY = m_bready;
+
+//Read Address (AR)
+assign ARID = 'b0;
+assign ARADDR = P_TARGET_SLAVE_BASE_ADDR + m_araddr;                            //Burst Length is number of transaction beats, minus 1
+assign ARLEN = 8'h0;                                               //Size should be P_DATA_WIDTH, in 2^n bytes, otherwise narrow bursts are used
+assign ARSIZE = 3'b100;                                 //INCR burst type is usually used, except for keyhole bursts
+assign ARBURST = 2'b01;
+assign ARCACHE = 4'b1100;
+assign ARPROT = 3'h0;
+assign ARQOS = 4'h0;
+assign ARVALID = m_arvalid;
+assign ARLOCK = 1'b0;                                                           //Update value to 4'b0011 if coherent accesses to be used via the Zynq ACP port. 
+                                                                                //Not Allocated, Modifiable, not Bufferable. Not Bufferable since this example is meant to test memory, not intermediate cache.
+
+//Read and Read Response (R)
+assign RREADY = m_rready;
+
+//Example design I/O
+//assign TXN_DONE = compare_done;
+//assign burst_size_bytes = P_WRITE_BURSTS * P_DATA_WIDTH / 8;                    //Burst size in bytes
+//assign init_txn_pulse = (!init_txn_ff2) && init_txn_ff;
+
+//Write Address Channel
+always @(posedge CLOCK) begin
+    if (RESET == 0) begin
+        m_awvalid <= 0;
+    end else if ((master_state == IDLE) & req_en & req_type) begin
+        m_awvalid <= 1;
+        //m_writer_counter <= m_writer_counter + 1;
+    end else if (AWREADY && m_awvalid) begin                                    //Once asserted, VALIDs cannot be de-asserted, so m_awvalid must wait until transaction is accepted
+        m_awvalid <= 0;
+        //m_writer_counter <= m_writer_counter - 1;
+    end else begin
+        m_awvalid <= m_awvalid;
+    end
+end
+
+always @(posedge CLOCK) begin
+    if (RESET == 0) begin
+        m_awaddr <= 0;
+    end else if ((master_state ==IDLE) & req_en & req_type) begin
+        m_awaddr <= req_addr;
+    end else if (AWREADY && m_awvalid) begin
+        m_awaddr <= 0;
+    end else begin
+        m_awaddr <= m_awaddr;
+    end
+end
+
+always @(posedge CLOCK) begin
+    if (RESET == 0) begin
+        m_araddr <= 0;
+    end else if ((master_state ==IDLE) & req_en & req_type) begin
+        m_araddr <= req_addr;
+    end else if (AWREADY && m_awvalid) begin
+        m_araddr <= 0;
+    end else begin
+        m_araddr <= m_awaddr;
+    end
+end
+
+always @(posedge CLOCK) begin
+    if (RESET == 0) begin
+        m_wvalid <= 0;
+    end else if ((master_state == REQ_STATE) & q_req_type) begin
+        m_wvalid <= 1;
+    end else if ((count==7) & WREADY && m_wvalid) begin
+        m_wvalid <= 0;
+    end else begin
+        m_wvalid <= m_wvalid;
+    end
+end
+
+always @(posedge CLOCK) begin
+    if (RESET == 0) begin
+        m_wlast <= 0;
+    end else if ((master_state == WRDATA_STATE) & (count == 7)) begin
+        m_wlast <= 1;
+    end else if (WREADY && m_wvalid) begin
+        m_wlast <= 0;
+    end else begin
+        m_wlast <= m_wlast;
+    end
+end
+
+//Write Data Generator.Data pattern is only a simple incrementing count from 0 for each burst.
+always @(posedge CLOCK) begin
+    if (RESET == 0) begin
+        m_wdata <= 0;
+    end else if (((master_state == REQ_STATE) & q_req_type) | (master_state == WRDATA_STATE)) begin
+        m_wdata <= q_req_data;
+    end else if(master_state == IDLE)begin
+        m_wdata <= 0;
+    end else begin 
+        m_wdata <= m_wdata;
+    end
+end
+
+//Write Response (B) Channel
+ always @(posedge CLOCK) begin
+    if (RESET == 0) begin
+        m_bready <= 0;
+    end else begin
+        m_bready <= 1;
+        //m_bready <= m_bready;
+    end
+end
+
+//Need this to silent VIP warning
+always @(posedge CLOCK) begin
+    if (RESET == 0) begin
+        m_arvalid <= 0;
+    end
+    else if((master_state == IDLE) & req_en & (~req_type))begin
+        m_arvalid <= 1'b1;
+    end
+    else if(ARVALID && ARREADY)begin
+        m_arvalid <= 1'b0;
+    end
+    else begin
+        m_arvalid <= m_arvalid;
+    end
+end
+
+//Need this to silent VIP warning
+always @(posedge CLOCK) begin
+    if (RESET == 0) begin
+        m_rready <= 0;
+        req_read_data <= 0;
+    end
+    else if(RDATA_STATE)begin
+        m_rready <= 1'b1;
+    end
+    else if(RVALID && m_rready)begin
+        m_rready <= 1'b0;
+        req_read_data <= RDATA;
+    end
+    else begin
+        m_rready <= m_rready;
+    end
+end
+
+always@(posedge CLOCK)begin
+  if(!RESET)begin
+    q_req_type <= 1'b0;
+    q_req_addr <= 32'h0;
+    q_req_data <= 128'h0;
+    q2_req_data <= 128'h0;
+  end
+  else begin
+      q_req_type <= req_type;
+      q_req_addr <= req_addr;
+      q_req_data <= req_data;
+      q2_req_data <= q_req_data;
+  end
+end
+
+assign axi_busy = (master_state == IDLE)? 1'b1:1'b0;
+
+
+//implement master command interface state machine
+always @ (posedge CLOCK) begin
+    if (RESET == 0) begin
+        master_state <= IDLE;
+        count <= 0;
+    end else begin
+        case (master_state)
+            IDLE: begin
+                if (req_en) begin
+                    master_state <= REQ_STATE;
+                end else begin
+                    master_state <= IDLE;
+                end
+                count <= 0;
+            end
+            REQ_STATE: begin
+                if ((q_req_type == 1'b1) &&(AWVALID & AWREADY))
+                    master_state <= WRDATA_STATE;
+                else if ((q_req_type == 1'b0) &&(ARVALID & ARREADY))
+                    master_state <= RDATA_STATE;
+                count <= 0;
+            end
+            WRDATA_STATE: begin
+                if (WREADY) begin
+                    if(count == 3'h7)
+                        master_state <= IDLE;
+                    else
+                        master_state <= WRDATA_STATE;
+                    count <= count + 3'h1 ;
+                end
+            end
+            RDATA_STATE: begin
+                if (RREADY) begin
+                    if(count == 3'h7)
+                        master_state <= IDLE;
+                    else
+                        master_state <= RDATA_STATE;
+                end
+                    count <= count + 3'h1 ;
+            end
+            default: begin
+                master_state <= IDLE;
+                count <= 0;
+            end
+        endcase
+    end
+end
+
+
+endmodule
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/interface/axi4_master.v
+//////////////////////////////////////////////////////////////////////
+
+
+
+//////////////////////////////////////////////////////////////////////
+//// Starting contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector_scripts//verilog/onecycle_stall.v
+//////////////////////////////////////////////////////////////////////
+/****************************************************************************
+          One cycle Stall circuit
+****************************************************************************/
+module onecyclestall(request,clk,resetn,stalled);
+input request;
+input clk;
+input resetn;
+output stalled;
+
+  reg T,Tnext;
+
+  // State machine for Stalling 1 cycle
+  always@(request or T)
+  begin
+    case(T) 
+      1'b0: Tnext=request;
+      1'b1: Tnext=0;
+    endcase 
+  end       
+  always@(posedge clk)
+    if (~resetn)
+      T<=0; 
+    else    
+      T<=Tnext;
+  assign stalled=(request&~T);
+endmodule
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector_scripts/verilog/onecycle_stall.v
+//////////////////////////////////////////////////////////////////////
+
+
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/local/per_lane_mem_wrapper.v
+//////////////////////////////////////////////////////////////////////
+
+module per_lane_mem_wrapper (
+  clk,
+        resetn,
+  address_a,
+  address_b,
+        rden_a,
+        rden_b,
+  wren_a,
+  wren_b,
+  data_a,
+  data_b,
+  out_a,
+  out_b
+);
+
+parameter AWIDTH=10;
+parameter NUM_WORDS=1024;
+parameter DWIDTH=32;
+
+input clk;
+input resetn;
+input [(AWIDTH-1):0] address_a;
+input [(AWIDTH-1):0] address_b;
+input  wren_a;
+input  wren_b;
+input  rden_a;
+input  rden_b;
+input [(DWIDTH-1):0] data_a;
+input [(DWIDTH-1):0] data_b;
+output [(DWIDTH-1):0] out_a;
+output [(DWIDTH-1):0] out_b;
+
+reg [(AWIDTH-1):0] q_address_a;
+reg [(AWIDTH-1):0] q_address_b;
+reg [(AWIDTH-1):0] mux_address_b;
+reg [(AWIDTH-1):0] mux_address_a;
+
+dpram inst_dpram(
+    .clk(clk),
+    .address_a(mux_address_a),
+    .address_b(mux_address_b),
+    .wren_a(wren_a),
+    .wren_b(wren_b),
+    .data_a(data_a),
+    .data_b(data_b),
+    .out_a(out_a),
+    .out_b(out_b)
+);
+defparam
+    inst_dpram.AWIDTH=AWIDTH,
+    inst_dpram.NUM_WORDS=NUM_WORDS,
+    inst_dpram.DWIDTH=DWIDTH;
+
+always@(posedge clk)begin
+   if(!resetn)begin
+     q_address_a <= 'h0;
+     q_address_b <= 'h0;
+   end
+   else begin
+     if(rden_a | wren_a)
+       q_address_a <= address_a;
+     if(rden_b | wren_b)
+       q_address_b <= address_b;
+   end
+end
+
+always@(*)begin
+
+  if(rden_a | wren_a)   
+    mux_address_a = address_a;
+  else
+    mux_address_a = q_address_a; 
+
+  if(rden_b | wren_b)   
+    mux_address_b = address_b;
+  else
+    mux_address_b = q_address_b;
+ 
+end
+
+endmodule
+//////////////////////////////////////////////////////////////////////
+//// Finshing contents of file: /mnt/f/ceremorphic/lizy/tpu_v2/tpu/design/vector_scripts/local/per_lane_mem_wrapper.v
+//////////////////////////////////////////////////////////////////////
